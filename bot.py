import asyncio
import logging
import random
import os
import requests
import tempfile
from datetime import datetime, timedelta
from telegram import Bot, InputMediaPhoto
from telegram.error import TelegramError
from telegram.request import HTTPXRequest
import schedule
import time
from threading import Thread
from bs4 import BeautifulSoup
from PIL import Image
import io
import httpx
import signal
import sys
from elevenlabs.client import ElevenLabs
from elevenlabs import play
import re

# Настройка логирования
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Конфигурация бота
BOT_TOKEN = os.getenv("BOT_TOKEN", "8437007902:AAFXbYzoWZI7lmg4EvF3DcopKXwbzYQgpkI")
CHANNEL_ID = os.getenv("CHANNEL_ID", "-1002722697999")  # Ваш канал
PIXABAY_API_KEY = os.getenv("PIXABAY_API_KEY")
UNSPLASH_API_KEY = os.getenv("UNSPLASH_API_KEY")
PEXELS_API_KEY = os.getenv("PEXELS_API_KEY")

# ElevenLabs конфигурация
ELEVENLABS_API_KEY = os.getenv("ELEVENLABS_API_KEY")
ELEVENLABS_VOICE_ID = os.getenv("ELEVENLABS_VOICE_ID")  # ID вашего клонированного голоса

class WorkBot:
    def __init__(self):
        # Настройка HTTP клиента с оптимизированными лимитами для Railway
        request = HTTPXRequest(
            connection_pool_size=10,  # Уменьшаем размер пула для стабильности
            pool_timeout=30,          # Уменьшаем таймаут пула
            read_timeout=30,          # Уменьшаем таймаут чтения
            write_timeout=30,         # Уменьшаем таймаут записи
            connect_timeout=30,       # Уменьшаем таймаут подключения
            http_version="1.1"        # Используем HTTP/1.1 для стабильности
        )
        self.bot = Bot(token=BOT_TOKEN, request=request)
        self.last_keywords = []
        self.voice_message_count = 0  # Счетчик голосовых сообщений
        self.last_message_id = None  # ID последнего отправленного сообщения для reply
        
        # Система предотвращения коллизий
        self.recent_messages = []  # Последние 20 сообщений
        self.recent_works = []     # Последние 50 работ
        self.max_recent_messages = 20
        self.max_recent_works = 50
        
        # Инициализация ElevenLabs клиента
        if ELEVENLABS_API_KEY:
            self.elevenlabs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)
            logger.info("✅ ElevenLabs клиент инициализирован")
        else:
            self.elevenlabs_client = None
            logger.warning("⚠️ ElevenLabs API ключ не найден, голосовые сообщения будут использовать gTTS")
        
        # Базовые элементы для генерации работ (бесконечная генерация)
        self.work_verbs = [
            "Покрасить", "Помыть", "Убрать", "Покосить", "Посидеть", 
            "Разобрать", "Покормить", "Почистить", "Поклеить", "Повесить",
            "Собрать", "Разложить", "Переставить", "Отремонтировать", "Починить",
            "Настроить", "Проверить", "Просушить", "Прогреть", "Охладить",
            "Загрузить", "Выгрузить", "Перевезти", "Доставить", "Забрать",
            "Принести", "Отнести", "Поднять", "Опустить", "Повернуть",
            "Сдвинуть", "Передвинуть", "Установить", "Снять", "Закрепить",
            "Открепить", "Соединить", "Разъединить", "Включить", "Выключить",
            "Открыть", "Закрыть", "Заблокировать", "Разблокировать", "Защитить"
        ]
        
        self.work_objects = [
            "забор", "дом", "машину", "окна", "полы", "стены", "двери", 
            "крышу", "подвал", "чердак", "балкон", "лестницу", "ворота",
            "калитку", "заборчик", "лавочку", "скамейку", "почтовый ящик",
            "люстру", "зеркала", "мебель", "технику", "инструменты", "одежду",
            "обувь", "посуду", "ковры", "шторы", "жалюзи", "радиаторы",
            "трубы", "краны", "розетки", "выключатели", "лампочки", "провода",
            "кабели", "антенну", "спутниковую тарелку", "кондиционер", "вентилятор",
            "печь", "камин", "духовку", "микроволновку", "холодильник", "стиральную машину",
            "посудомойку", "пылесос", "утюг", "фен", "бритву", "электробритву",
            "телефон", "компьютер", "принтер", "сканер", "роутер", "модем",
            "телевизор", "музыкальный центр", "колонки", "наушники", "камеру",
            "фотоаппарат", "видеокамеру", "проектор", "экран", "доску", "плакаты",
            "картины", "фотографии", "рамки", "вазы", "статуэтки", "сувениры",
            "книги", "журналы", "газеты", "документы", "папки", "файлы",
            "диски", "флешки", "карты памяти", "батарейки", "зарядные устройства",
            "кабели зарядки", "адаптеры", "переходники", "разветвители", "удлинители",
            "фильтры", "картриджи", "тонер", "бумагу", "ручки", "карандаши",
            "маркеры", "фломастеры", "краски", "кисти", "валики", "шпатели",
            "отвертки", "ключи", "молотки", "гвозди", "шурупы", "болты", "гайки",
            "шайбы", "прокладки", "герметик", "клей", "скотч", "изоленту",
            "проволоку", "веревку", "шнур", "цепь", "трос", "канат", "леску",
            "сеть", "ткань", "пленку", "фольгу", "бумагу", "картон", "пенопласт",
            "поролон", "вата", "вата", "синтепон", "пух", "перья", "шерсть",
            "мех", "кожу", "замшу", "велюр", "бархат", "атлас", "шелк",
            "хлопок", "лен", "шерсть", "кашемир", "ангора", "мохер", "альпака",
            "верблюжья шерсть", "як", "лама", "викунья", "гуанако", "сурок",
            "бобр", "норка", "соболь", "куница", "горностай", "ласка", "хорек",
            "енот", "лиса", "волк", "медведь", "тигр", "леопард", "ягуар",
            "пума", "рысь", "каракал", "сервал", "оцелот", "маргай", "онцилла",
            "кот", "кошка", "котенок", "котенок", "котенок", "котенок", "котенок"
        ]
        
        self.work_locations = [
            "в доме", "в квартире", "в офисе", "в магазине", "в кафе", "в ресторане",
            "в школе", "в больнице", "в поликлинике", "в аптеке", "в банке", "в почте",
            "в библиотеке", "в музее", "в театре", "в кинотеатре", "в спортзале",
            "в бассейне", "в сауне", "в бане", "в гараже", "в подвале", "на чердаке",
            "на балконе", "на лоджии", "на террасе", "на веранде", "в саду", "в огороде",
            "в парке", "во дворе", "на улице", "на дороге", "на тротуаре", "на площади",
            "на стадионе", "на арене", "на сцене", "на подиуме", "на трибуне", "на скамейке",
            "на лавочке", "на стуле", "на кресле", "на диване", "на кровати", "на матрасе",
            "на подушке", "на одеяле", "на простыне", "на наволочке", "на пододеяльнике",
            "на покрывале", "на плед", "на ковре", "на паласе", "на линолеуме", "на паркете",
            "на ламинате", "на плитке", "на мраморе", "на граните", "на бетоне", "на асфальте",
            "на земле", "на траве", "на песке", "на камнях", "на гальке", "на щебне",
            "на гравии", "на глине", "на иле", "на грязи", "на снегу", "на льду",
            "на воде", "на реке", "на озере", "на море", "на океане", "на пруду",
            "на болоте", "на лугу", "на поле", "на горе", "на холме", "на склоне",
            "на вершине", "на дне", "на дне", "на дне", "на дне", "на дне"
        ]
        
        self.work_conditions = [
            "от грязи", "от пыли", "от мусора", "от листьев", "от снега", "от льда",
            "от ржавчины", "от накипи", "от жира", "от копоти", "от сажи", "от клея",
            "от краски", "от лака", "от воска", "от масла", "от бензина", "от солярки",
            "от керосина", "от ацетона", "от спирта", "от уксуса", "от соли", "от сахара",
            "от меда", "от варенья", "от джема", "от сиропа", "от соуса", "от кетчупа",
            "от майонеза", "от горчицы", "от хрена", "от перца", "от специй", "от трав",
            "от цветов", "от фруктов", "от овощей", "от ягод", "от грибов", "от орехов",
            "от семечек", "от зерен", "от крупы", "от муки", "от сахара", "от соли",
            "от соды", "от дрожжей", "от закваски", "от кефира", "от йогурта", "от творога",
            "от сыра", "от масла", "от маргарина", "от сала", "от мяса", "от рыбы",
            "от птицы", "от яиц", "от молока", "от сливок", "от сметаны", "от майонеза",
            "от кетчупа", "от соуса", "от подливы", "от бульона", "от супа", "от борща",
            "от щей", "от рассольника", "от солянки", "от ухи", "от харчо", "от лагмана",
            "от плова", "от шашлыка", "от шаурмы", "от бургера", "от пиццы", "от пасты",
            "от риса", "от гречки", "от перловки", "от пшена", "от овсянки", "от манки",
            "от кукурузы", "от гороха", "от фасоли", "от чечевицы", "от нута", "от маша",
            "от сои", "от арахиса", "от миндаля", "от грецких орехов", "от фундука", "от кешью",
            "от фисташек", "от кедровых орехов", "от бразильских орехов", "от макадамии", "от пекана", "от орехов пекан"
        ]
        
        self.prices = [
            "одна тысяча рублей", "одна тысяча двести рублей", "одна тысяча пятьсот рублей", 
            "одна тысяча восемьсот рублей", "две тысячи рублей", "две тысячи триста рублей",
            "две тысячи пятьсот рублей", "две тысячи восемьсот рублей", "три тысячи рублей",
            "три тысячи пятьсот рублей", "четыре тысячи рублей", "четыре тысячи триста рублей",
            "четыре тысячи пятьсот рублей", "пять тысяч рублей", "три тысячи восемьсот рублей",
            "две тысячи семьсот рублей", "три тысячи двести рублей", "четыре тысячи восемьсот рублей",
            "одна тысяча семьсот рублей", "две тысячи девятьсот рублей", "три тысячи шестьсот рублей"
        ]
        
        self.bonuses = [
            # Новые необычные варианты мата
            "такси с меня, ебаный насос",
            "такси с меня, брали срали грелись", 
            "такси с меня, пизда рулю",
            "такси с меня, вот сосалово",
            "такси с меня, ебал мать",
            "такси с меня, сын шлюхи",
            "такси с меня, похуй плюс похуй",
            "такси с меня, попердеть в хуй",
            "такси с меня, нассать в глаза",
            "такси с меня, кончал на носик сучке",
            "такси с меня, сучка закрехтела",
            "такси с меня, наквакал ей на писю",
            # Старые варианты
            "такси с меня, блядь",
            "такси с меня, епта", 
            "такси с меня, сука",
            "такси с меня, бляяя",
            "такси с меня, ебать",
            "такси с меня, бляха-муха",
            "такси с меня, епты бля",
            "такси с меня, блядски",
            "обед, блядь", 
            "обед борщ, епта", 
            "в подарок бу клей, сука",
            "инвентарь даю, бляяя",
            "материалы даю, ебать",
            "чай с печеньками, бляха-муха",
            "кофе с булочкой, епты бля",
            "обед + чай, блядски",
            "материалы + обед, блядь",
            "такси + обед, епта",
            "инвентарь + обед, сука",
            "в подарок инструмент, бляяя",
            "обед + десерт, ебать",
            "материалы + такси, бляха-муха",
            "чай + печеньки, епты бля",
            "в подарок набор дюбелей, блядски",
            "в подарок перфоратор, блядь",
            "в подарок болгарка, епта",
            "в подарок дрель, сука",
            "в подарок набор ключей, бляяя",
            "в подарок молоток, ебать",
            "в подарок отвертки, бляха-муха",
            "в подарок плоскогубцы, епты бля",
            "в подарок ножовку, блядски",
            "в подарок лопату, блядь",
            "в подарок грабли, епта",
            "в подарок ведро, сука",
            "в подарок тряпки, бляяя",
            "в подарок швабру, ебать",
            # Странные подарки
            "в подарок ковер для мыши, бляха-муха",
            "в подарок насвай, епты бля",
            "в подарок вторяк снюса, блядски",
            "в подарок старую зубную щетку, блядь",
            "в подарок ржавый гвоздь, епта",
            "в подарок пустую бутылку, сука",
            "в подарок сломанную лампочку, бляяя",
            "в подарок старую газету, ебать",
            "в подарок пустую коробку, бляха-муха",
            "в подарок ржавую шайбу, епты бля",
            "в подарок старую кнопку, блядски",
            "в подарок пустую упаковку, блядь",
            "в подарок сломанную зажигалку, епта",
            "в подарок старую резинку, сука",
            "в подарок пустую спичечную коробку, бляяя",
            "в подарок сломанную ручку, ебать",
            "в подарок ржавую скрепку, бляха-муха",
            "в подарок старую наклейку, епты бля",
            "в подарок пустую банку от кофе, блядски",
            "в подарок сломанную заколку, блядь",
            "в подарок ржавую кнопку от джинсов, епта",
            "в подарок старую наклейку с ценой, сука",
            "в подарок пустую упаковку от жвачки, бляяя",
            "в подарок сломанную зубочистку, ебать",
            "в подарок ржавую скрепку для денег, бляха-муха",
            "в подарок старую резинку для волос, епты бля",
            "в подарок пустую коробку от таблеток, блядски",
            "в подарок сломанную заколку для волос, блядь",
            "в подарок ржавую кнопку от рубашки, епта",
            "в подарок старую наклейку с адресом, сука",
            "в подарок пустую упаковку от конфет, бляяя",
            "в подарок сломанную зубочистку для зубов, ебать",
            "в подарок ржавую скрепку для документов, бляха-муха",
            "в подарок старую резинку для резинки, епты бля",
            "в подарок пустую коробку от витаминов, блядски",
            "в подарок сломанную заколку для заколки, блядь",
            "в подарок ржавую кнопку от куртки, епта",
            "в подарок старую наклейку с телефоном, сука",
            "в подарок пустую упаковку от печенья, бляяя",
            # Более человеческие подарки без повторов
            "в подарок старую зубную щетку, ебать",
            "в подарок ржавый гвоздь, бляха-муха",
            "в подарок пустую бутылку, епты бля",
            "в подарок сломанную лампочку, блядски",
            "в подарок старую газету, блядь",
            "в подарок пустую коробку, епта",
            "в подарок ржавую шайбу, сука",
            "в подарок старую кнопку, бляяя",
            "в подарок пустую упаковку, ебать",
            "в подарок сломанную зажигалку, бляха-муха",
            "в подарок старую резинку, епты бля",
            "в подарок пустую спичечную коробку, блядски",
            "в подарок сломанную ручку, блядь",
            "в подарок ржавую скрепку, епта",
            "в подарок старую наклейку, сука",
            "в подарок пустую банку от кофе, бляяя",
            "в подарок сломанную заколку, ебать",
            "в подарок ржавую кнопку от джинсов, бляха-муха",
            "в подарок старую наклейку с ценой, епты бля",
            "в подарок пустую упаковку от жвачки, блядски",
            "в подарок сломанную зубочистку, блядь",
            "в подарок ржавую скрепку для денег, епта",
            "в подарок старую резинку для волос, сука",
            "в подарок пустую коробку от таблеток, бляяя",
            "в подарок сломанную заколку для волос, ебать",
            "в подарок ржавую кнопку от рубашки, бляха-муха",
            "в подарок старую наклейку с адресом, епты бля",
            "в подарок пустую упаковку от конфет, блядски",
            "в подарок сломанную зубочистку для зубов, блядь",
            "в подарок ржавую скрепку для документов, епта",
            "в подарок старую резинку для резинки, сука",
            "в подарок пустую коробку от витаминов, бляяя"
        ]
        
        # Дополнительные элементы в стиле примеров (расширенные с матом и угаром)
        self.extra_info = [
            "за пару часов, блядь",
            "на руки, епты бля",
            "косилка есть, ебать",
            "места ограничены, бляяя",
            "так же стоит шведский стол, епта",
            "инструменты дам, бляха-муха",
            "материалы есть, ебать как",
            "быстро сделать, блядски",
            "срочно нужно, ептыть",
            "инвентарь свой, блядь",
            "все даю, ебать бля",
            "быстро и качественно, бляяя",
            "опыт не важен, епта",
            "главное желание, бляха-муха",
            "за день сделаем, ебать",
            "инструменты предоставлю, блядски",
            "все необходимое есть, епты бля",
            "работа легкая, блядь",
            "деньги сразу, ебать как",
            "наличными, бляяя",
            "в подарок дам старую отвертку, епта",
            "еще и ржавый болт подарю, бляха-муха",
            "чай с печеньками, ебать бля",
            "обед борщ, блядски",
            "в подарок бу клей, ептыть",
            "материалы + обед, блядь",
            "такси + обед, ебать как",
            "инвентарь + обед, бляяя",
            "в подарок инструмент, епта",
            "обед + десерт, бляха-муха",
            "материалы + такси, ебать бля",
            "чай + печеньки, блядски",
            "в подарок набор дюбелей, ептыть",
            "в подарок перфоратор, блядь",
            "в подарок болгарка, ебать как",
            "в подарок дрель, бляяя",
            "в подарок набор ключей, епта",
            "в подарок молоток, бляха-муха",
            "в подарок отвертки, ебать бля",
            "в подарок плоскогубцы, блядски",
            "в подарок ножовку, ептыть",
            "в подарок лопату, блядь",
            "в подарок грабли, ебать как",
            "в подарок ведро, бляяя",
            "в подарок тряпки, епта",
            "в подарок швабру, бляха-муха",
            # Новые кринжовые фразы
            "очень срочно, блядь",
            "прям щас нужно, епты бля",
            "завтра уже поздно, ебать",
            "вчера было бы лучше, бляяя",
            "срочняк полный, епта",
            "горящий заказ, бляха-муха",
            "прям горит все, ебать бля",
            "очень горючий, блядски",
            "прям пылает, ептыть",
            "срочняк как в аптеке, блядь",
            "прям как в больнице, ебать как",
            "очень срочно как в морге, бляяя",
            "прям как в тюрьме, епта",
            "срочняк как в армии, бляха-муха",
            "прям как в школе, ебать бля",
            "очень срочно как в детсаду, блядски",
            "прям как в больнице, ептыть",
            "срочняк как в полиции, блядь",
            "прям как в пожарной, ебать как",
            "очень срочно как в скорой, бляяя",
            "прям как в милиции, епта",
            "срочняк как в КГБ, бляха-муха",
            "прям как в ФСБ, ебать бля",
            "очень срочно как в ЦРУ, блядски",
            "прям как в МИ-6, ептыть",
            "срочняк как в Моссаде, блядь",
            "прям как в Штази, ебать как",
            "очень срочно как в Гестапо, бляяя",
            "прям как в НКВД, епта",
            "срочняк как в СМЕРШ, бляха-муха",
            "прям как в ОГПУ, ебать бля",
            "очень срочно как в ЧК, блядски",
            "прям как в ВЧК, ептыть",
            "срочняк как в ГПУ, блядь",
            "прям как в НКГБ, ебать как",
            "очень срочно как в МГБ, бляяя",
            "прям как в КГБ СССР, епта",
            "срочняк как в ФСБ РФ, бляха-муха",
            "прям как в СВР, ебать бля",
            "очень срочно как в ФСО, блядски",
            "прям как в Росгвардии, ептыть",
            "срочняк как в Росгвардии, блядь",
            "прям как в ВВ МВД, ебать как",
            "очень срочно как в ОМОН, бляяя",
            "прям как в СОБР, епта",
            "срочняк как в ГИБДД, бляха-муха",
            "прям как в ДПС, ебать бля",
            "очень срочно как в ППС, блядски",
            "прям как в УУП, ептыть",
            "срочняк как в УУМ, блядь",
            "прям как в УУПиП, ебать как",
            "очень срочно как в УУПиПН, бляяя",
            "прям как в УУПиПНП, епта",
            "срочняк как в УУПиПНПР, бляха-муха",
            "прям как в УУПиПНПРС, ебать бля",
            "очень срочно как в УУПиПНПРСТ, блядски",
            "прям как в УУПиПНПРСТУ, ептыть",
            "срочняк как в УУПиПНПРСТУФ, блядь",
            "прям как в УУПиПНПРСТУФХ, ебать как",
            "очень срочно как в УУПиПНПРСТУФХЦ, бляяя",
            "прям как в УУПиПНПРСТУФХЦЧ, епта",
            "срочняк как в УУПиПНПРСТУФХЦЧШ, бляха-муха",
            "прям как в УУПиПНПРСТУФХЦЧШЩ, ебать бля",
            "очень срочно как в УУПиПНПРСТУФХЦЧШЩЪ, блядски",
            "прям как в УУПиПНПРСТУФХЦЧШЩЪЫ, ептыть",
            "срочняк как в УУПиПНПРСТУФХЦЧШЩЪЫЬ, блядь",
            "прям как в УУПиПНПРСТУФХЦЧШЩЪЫЬЭ, ебать как",
            "очень срочно как в УУПиПНПРСТУФХЦЧШЩЪЫЬЭЮ, бляяя",
            "прям как в УУПиПНПРСТУФХЦЧШЩЪЫЬЭЮЯ, епта",
            # Еще больше смешных фраз
            "прям как в Макдональдсе, блядь",
            "очень срочно как в КФС, епты бля",
            "прям как в Бургер Кинге, ебать",
            "очень срочно как в Сабвее, бляяя",
            "прям как в Домино, епта",
            "очень срочно как в Пицца Хат, бляха-муха",
            "прям как в Старбаксе, ебать бля",
            "очень срочно как в Кофе Хаусе, блядски",
            "прям как в Шоколаднице, ептыть",
            "очень срочно как в Кофеин, блядь",
            "прям как в Азбуке Вкуса, ебать как",
            "очень срочно как в Перекрестке, бляяя",
            "прям как в Пятерочке, епта",
            "очень срочно как в Магните, бляха-муха",
            "прям как в Ленте, ебать бля",
            "очень срочно как в Ашане, блядски",
            "прям как в Метро, ептыть",
            "очень срочно как в Окее, блядь",
            "прям как в Дикси, ебать как",
            "очень срочно как в Верном, бляяя",
            "прям как в Семье, епта",
            "очень срочно как в Утке, бляха-муха",
            "прям как в Глобусе, ебать бля",
            "очень срочно как в М.Видео, блядски",
            "прям как в Эльдорадо, ептыть",
            "очень срочно как в DNS, блядь",
            "прям как в Ситилинке, ебать как",
            "очень срочно как в Технопарке, бляяя",
            "прям как в Регарде, епта",
            "очень срочно как в Связном, бляха-муха",
            "прям как в Евросети, ебать бля",
            "очень срочно как в Билайне, блядски",
            "прям как в МТС, ептыть",
            "очень срочно как в Мегафоне, блядь",
            "прям как в Теле2, ебать как",
            "очень срочно как в Ростелекоме, бляяя",
            "прям как в Дом.ру, епта",
            "очень срочно как в Онлайме, бляха-муха",
            "прям как в Акадо, ебать бля",
            "очень срочно как в Эр-Телекоме, блядски",
            "прям как в ТТК, ептыть",
            "очень срочно как в МГТС, блядь",
            "прям как в Стриме, ебать как",
            "очень срочно как в Космосе, бляяя",
            "прям как в Нетбине, епта",
            "очень срочно как в Смартс, бляха-муха",
            "прям как в Вайлдберриз, ебать бля",
            "очень срочно как в Озоне, блядски",
            "прям как в Алиэкспрессе, ептыть",
            "очень срочно как в Амазоне, блядь",
            "прям как в Ибее, ебать как",
            "очень срочно как в Авито, бляяя",
            "прям как в Юле, епта",
            "очень срочно как в Дроме, бляха-муха",
            "прям как в Авто.ру, ебать бля",
            "очень срочно как в Циане, блядски",
            "прям как в Домклике, ептыть",
            "очень срочно как в Ламоде, блядь",
            "прям как в Асосе, ебать как",
            "очень срочно как в Зара, бляяя",
            "прям как в Х&М, епта",
            "очень срочно как в Юникло, бляха-муха",
            "прям как в Массмо, ебать бля",
            "очень срочно как в Индитексе, блядски",
            "прям как в Приме, ептыть",
            "очень срочно как в Страдивариусе, блядь",
            "прям как в Спортмастере, ебать как",
            "очень срочно как в Декатлоне, бляяя",
            "прям как в Адидасе, епта",
            "очень срочно как в Найке, бляха-муха",
            "прям как в Пума, ебать бля",
            "очень срочно как в Рибоке, блядски",
            "прям как в Нью Балансе, ептыть",
            "очень срочно как в Конверсе, блядь",
            "прям как в Вансе, ебать как",
            "очень срочно как в Филле, бляяя",
            "прям как в Асиксе, епта",
            "очень срочно как в Мизуно, бляха-муха",
            "прям как в Саломоне, ебать бля",
            "очень срочно как в Нордвее, блядски",
            "прям как в Коламбии, ептыть",
            "очень срочно как в Патагонии, блядь",
            "прям как в Норд Фейсе, ебать как",
            "очень срочно как в Мамонте, бляяя",
            "прям как в Блэк Яке, епта",
            "очень срочно как в Бергхаусе, бляха-муха",
            "прям как в Хелли Хансене, ебать бля",
            "очень срочно как в Фьордленде, блядски",
            "прям как в Ред Фоксе, ептыть",
            "очень срочно как в Треффе, блядь",
            "прям как в Спортлайфе, ебать как",
            "очень срочно как в Спортландии, бляяя",
            "прям как в Спортхиме, епта",
            "очень срочно как в Спортмаксе, бляха-муха",
            "прям как в Спортэксе, ебать бля",
            "очень срочно как в Спортплюсе, блядски",
            "прям как в Спортмании, ептыть",
            "очень срочно как в Спортланде, блядь",
            "прям как в Спортмаре, ебать как",
            "очень срочно как в Спортмаге, бляяя",
            "прям как в Спортмате, епта",
            "очень срочно как в Спортмане, бляха-муха",
            "прям как в Спортмаке, ебать бля",
            "очень срочно как в Спортмале, блядски",
            "прям как в Спортмасе, ептыть",
            "очень срочно как в Спортмаше, блядь",
            "прям как в Спортмаще, ебать как",
            "очень срочно как в Спортмаще, бляяя",
            "прям как в Спортмаще, епта"
        ]
        
        # Дополнительные элементы (как от работяги) с матом и угаром
        self.quirky_additions = [
            "забор красить аккуратно, блядь",
            "бабушка ворчит но не злая, епты бля",
            "крыльцо отмыть до блеска, ебать",
            "дом помыть хорошо, бляяя",
            "снег убирать осторожно, епта",
            "машину помыть до блеска, бляха-муха",
            "траву косить ровно, ебать бля",
            "стены красить аккуратно, блядски",
            "мусор убирать весь, ептыть",
            "окна помыть чисто, блядь",
            "ворота покрасить хорошо, ебать как",
            "листья убрать все, бляяя",
            "полы помыть до блеска, епта",
            "заборчик покрасить ровно, бляха-муха",
            "снег убирать аккуратно, ебать бля",
            "посуду помыть чисто, блядски",
            "лавочку покрасить хорошо, ептыть",
            "мусор убрать весь, блядь",
            "двери помыть до блеска, ебать как",
            "калитку покрасить ровно, бляяя",
            "собака лает но не кусается, епта",
            "соседи ворчат но не мешают, бляха-муха",
            "работать можно в любое время, ебать бля",
            "деньги дам сразу после работы, блядски",
            "еще и чай с печеньками, ептыть",
            "в подарок дам старую отвертку, блядь",
            "материалы все есть, ебать как",
            "инструменты предоставлю, бляяя",
            "опыт не важен, епта",
            "главное желание работать, бляха-муха",
            # Новые кринжовые фразы
            "очень аккуратно красить, блядь",
            "прям до блеска все, епты бля",
            "как в больнице чисто, ебать",
            "прям как в операционной, бляяя",
            "очень стерильно, епта",
            "прям как в лаборатории, бляха-муха",
            "очень чисто как в аптеке, ебать бля",
            "прям как в морге, блядски",
            "очень аккуратно как в тюрьме, ептыть",
            "прям как в армии, блядь",
            "очень чисто как в школе, ебать как",
            "прям как в детсаду, бляяя",
            "очень аккуратно как в больнице, епта",
            "прям как в полиции, бляха-муха",
            "очень чисто как в пожарной, ебать бля",
            "прям как в скорой, блядски",
            "очень аккуратно как в милиции, ептыть",
            "прям как в КГБ, блядь",
            "очень чисто как в ФСБ, ебать как",
            "прям как в ЦРУ, бляяя",
            "очень аккуратно как в МИ-6, епта",
            "прям как в Моссаде, бляха-муха",
            "очень чисто как в Штази, ебать бля",
            "прям как в Гестапо, блядски",
            "очень аккуратно как в НКВД, ептыть",
            "прям как в СМЕРШ, блядь",
            "очень чисто как в ОГПУ, ебать как",
            "прям как в ЧК, бляяя",
            "очень аккуратно как в ВЧК, епта",
            "прям как в ГПУ, бляха-муха",
            "очень чисто как в НКГБ, ебать бля",
            "прям как в МГБ, блядски",
            "очень аккуратно как в КГБ СССР, ептыть",
            "прям как в ФСБ РФ, блядь",
            "очень чисто как в СВР, ебать как",
            "прям как в ФСО, бляяя",
            "очень аккуратно как в Росгвардии, епта",
            "прям как в ВВ МВД, бляха-муха",
            "очень чисто как в ОМОН, ебать бля",
            "прям как в СОБР, блядски",
            "очень аккуратно как в ГИБДД, ептыть",
            "прям как в ДПС, блядь",
            "очень чисто как в ППС, ебать как",
            "прям как в УУП, бляяя",
            "очень аккуратно как в УУМ, епта",
            "прям как в УУПиП, бляха-муха",
            "очень чисто как в УУПиПН, ебать бля",
            "прям как в УУПиПНП, блядски",
            "очень аккуратно как в УУПиПНПР, ептыть",
            "прям как в УУПиПНПРС, блядь",
            "очень чисто как в УУПиПНПРСТ, ебать как",
            "прям как в УУПиПНПРСТУ, бляяя",
            "очень аккуратно как в УУПиПНПРСТУФ, епта",
            "прям как в УУПиПНПРСТУФХ, бляха-муха",
            "очень чисто как в УУПиПНПРСТУФХЦ, ебать бля",
            "прям как в УУПиПНПРСТУФХЦЧ, блядски",
            "очень аккуратно как в УУПиПНПРСТУФХЦЧШ, ептыть",
            "прям как в УУПиПНПРСТУФХЦЧШЩ, блядь",
            "очень чисто как в УУПиПНПРСТУФХЦЧШЩЪ, ебать как",
            "прям как в УУПиПНПРСТУФХЦЧШЩЪЫ, бляяя",
            "очень аккуратно как в УУПиПНПРСТУФХЦЧШЩЪЫЬ, епта",
            "прям как в УУПиПНПРСТУФХЦЧШЩЪЫЬЭ, бляха-муха",
            "очень чисто как в УУПиПНПРСТУФХЦЧШЩЪЫЬЭЮ, ебать бля",
            "прям как в УУПиПНПРСТУФХЦЧШЩЪЫЬЭЮЯ, блядски"
        ]
        
        # Фразы для ответных постов (работодатель помечает, что работа выполнена) с матом
        self.completion_phrases = [
            "уже сделали, спасибо, блядь",
            "работа выполнена, все четка, епты бля",
            "сделали быстро и качественно, ебать",
            "готово, спасибо за работу, бляяя",
            "выполнили, все как надо, епта",
            "сделали, работали хорошо, бляха-муха",
            "готово, качественно поработали, ебать бля",
            "выполнили, спасибо, блядски",
            "сделали быстро, все четка, ептыть",
            "готово, работали как надо, блядь",
            "выполнили качественно, ебать как",
            "сделали, спасибо за работу, бляяя",
            "готово, все четка, епта",
            "выполнили быстро и хорошо, бляха-муха",
            "сделали, работали качественно, ебать бля",
            "готово, спасибо, блядски",
            "выполнили, все как надо, ептыть",
            "сделали быстро, спасибо, блядь",
            "готово, качественно поработали, ебать как",
            "выполнили, работали хорошо, бляяя",
            "сделали на совесть, епта",
            "работали как звери, бляха-муха",
            "все четка сделали, ебать бля",
            "качественно поработали, блядски",
            "быстро и хорошо, ептыть",
            "все как надо, блядь",
            "работали отлично, ебать как",
            "сделали на ура, бляяя",
            "все четка, епта",
            "работали как надо, бляха-муха"
        ]
        
        # Дополнительные детали для ответных постов (тупые подарки) с матом
        self.completion_details = [
            "еще и 15 гвоздей подарили, блядь",
            "еще и флешку 5гб дали, епты бля",
            "еще и старую батарейку оставили, ебать",
            "еще и ржавый болт подарили, бляяя",
            "еще и сломанную отвертку дали, епта",
            "еще и пустую банку из-под краски оставили, бляха-муха",
            "еще и кусок проволоки подарили, ебать бля",
            "еще и старую тряпку дали, блядски",
            "еще и пустую бутылку оставили, ептыть",
            "еще и сломанный карандаш подарили, блядь",
            "еще и ржавую шайбу дали, ебать как",
            "еще и кусок скотча оставили, бляяя",
            "еще и старую газету подарили, епта",
            "еще и сломанную лампочку дали, бляха-муха",
            "еще и пустую коробку оставили, ебать бля",
            "еще и ржавый гвоздь подарили, блядски",
            "еще и старую кнопку дали, ептыть",
            "еще и пустую упаковку оставили, блядь",
            "еще и сломанную зажигалку подарили, ебать как",
            "еще и ржавую шайбу дали, бляяя",
            "еще и старую резинку оставили, епта",
            "еще и пустую спичечную коробку подарили, бляха-муха",
            "еще и сломанную ручку дали, ебать бля",
            "еще и ржавую скрепку оставили, блядски",
            "еще и старую наклейку подарили, ептыть",
            # Новые кринжовые подарки
            "еще и 3 сломанных зубочистки дали, блядь",
            "еще и пустую коробку от спичек оставили, епты бля",
            "еще и ржавую скрепку для бумаг подарили, ебать",
            "еще и старую резинку для волос дали, бляяя",
            "еще и пустую банку от кофе оставили, епта",
            "еще и сломанную заколку подарили, бляха-муха",
            "еще и ржавую кнопку от джинсов дали, ебать бля",
            "еще и старую наклейку с ценой оставили, блядски",
            "еще и пустую упаковку от жвачки подарили, ептыть",
            "еще и сломанную зубочистку дали, блядь",
            "еще и ржавую скрепку для денег оставили, ебать как",
            "еще и старую резинку для резины подарили, бляяя",
            "еще и пустую коробку от таблеток дали, епта",
            "еще и сломанную заколку для волос оставили, бляха-муха",
            "еще и ржавую кнопку от рубашки подарили, ебать бля",
            "еще и старую наклейку с адресом дали, блядски",
            "еще и пустую упаковку от конфет оставили, ептыть",
            "еще и сломанную зубочистку для зубов подарили, блядь",
            "еще и ржавую скрепку для документов дали, ебать как",
            "еще и старую резинку для резинки оставили, бляяя",
            "еще и пустую коробку от витаминов подарили, епта",
            "еще и сломанную заколку для заколки дали, бляха-муха",
            "еще и ржавую кнопку от куртки оставили, ебать бля",
            "еще и старую наклейку с телефоном подарили, блядски",
            "еще и пустую упаковку от печенья дали, ептыть",
            "еще и сломанную зубочистку для зубочистки оставили, блядь",
            "еще и ржавую скрепку для скрепки подарили, ебать как",
            "еще и старую резинку для резинки резинки дали, бляяя",
            "еще и пустую коробку от коробки оставили, епта",
            "еще и сломанную заколку для заколки заколки подарили, бляха-муха",
            "еще и ржавую кнопку от кнопки дали, ебать бля",
            "еще и старую наклейку с наклейкой оставили, блядски",
            "еще и пустую упаковку от упаковки подарили, ептыть",
            "еще и сломанную зубочистку для зубочистки зубочистки дали, блядь",
            "еще и ржавую скрепку для скрепки скрепки оставили, ебать как",
            "еще и старую резинку для резинки резинки резинки подарили, бляяя",
            "еще и пустую коробку от коробки коробки дали, епта",
            "еще и сломанную заколку для заколки заколки заколки оставили, бляха-муха",
            "еще и ржавую кнопку от кнопки кнопки подарили, ебать бля",
            "еще и старую наклейку с наклейкой наклейкой дали, блядски",
            "еще и пустую упаковку от упаковки упаковки оставили, ептыть",
            "еще и сломанную зубочистку для зубочистки зубочистки зубочистки подарили, блядь",
            "еще и ржавую скрепку для скрепки скрепки скрепки дали, ебать как",
            "еще и старую резинку для резинки резинки резинки резинки оставили, бляяя",
            "еще и пустую коробку от коробки коробки коробки подарили, епта",
            "еще и сломанную заколку для заколки заколки заколки заколки дали, бляха-муха",
            "еще и ржавую кнопку от кнопки кнопки кнопки оставили, ебать бля",
            "еще и старую наклейку с наклейкой наклейкой наклейкой подарили, блядски",
            "еще и пустую упаковку от упаковки упаковки упаковки дали, ептыть",
            "еще и сломанную зубочистку для зубочистки зубочистки зубочистки зубочистки оставили, блядь",
            "еще и ржавую скрепку для скрепки скрепки скрепки скрепки подарили, ебать как",
            "еще и старую резинку для резинки резинки резинки резинки резинки дали, бляяя",
            "еще и пустую коробку от коробки коробки коробки коробки оставили, епта",
            "еще и сломанную заколку для заколки заколки заколки заколки заколки подарили, бляха-муха",
            "еще и ржавую кнопку от кнопки кнопки кнопки кнопки дали, ебать бля",
            "еще и старую наклейку с наклейкой наклейкой наклейкой наклейкой оставили, блядски",
            "еще и пустую упаковку от упаковки упаковки упаковки упаковки подарили, ептыть",
            "еще и сломанную зубочистку для зубочистки зубочистки зубочистки зубочистки зубочистки дали, блядь",
            "еще и ржавую скрепку для скрепки скрепки скрепки скрепки скрепки оставили, ебать как",
            "еще и старую резинку для резинки резинки резинки резинки резинки резинки подарили, бляяя",
            "еще и пустую коробку от коробки коробки коробки коробки коробки дали, епта",
            "еще и сломанную заколку для заколки заколки заколки заколки заколки заколки оставили, бляха-муха",
            "еще и ржавую кнопку от кнопки кнопки кнопки кнопки кнопки подарили, ебать бля",
            "еще и старую наклейку с наклейкой наклейкой наклейкой наклейкой наклейкой дали, блядски",
            "еще и пустую упаковку от упаковки упаковки упаковки упаковки упаковки оставили, ептыть"
        ]

    def generate_work_type(self):
        """Генерирует новый тип работы с предотвращением коллизий"""
        max_attempts = 50  # Максимум попыток для избежания бесконечного цикла
        
        for attempt in range(max_attempts):
            # 30% шанс использовать специальные работы
            if random.random() < 0.3:
                special_works = [
                    "Набираем массовку для съемок, блядь",
                    "Зачистить участок от бурьяна, епта", 
                    "Разобрать ступеньки на крыльце, сука",
                    "Посидеть с бабушкой, бляяя",
                    "Покормить кота, ебать",
                    "Помыть велосипед, бляха-муха",
                    "Убрать паутину с потолка, епты бля",
                    "Покрасить почтовый ящик, блядски",
                    "Убрать пыль с книг, блядь",
                    "Помыть люстру, епта",
                    "Покрасить лестницу, сука",
                    "Убрать мусор из сарая, бляяя",
                    "Помыть пол в гараже, ебать",
                    "Покрасить трубы, бляха-муха",
                    "Убрать снег с крыши гаража, епты бля",
                    "Помыть забор, блядски",
                    "Покрасить дверь в подъезд, блядь"
                ]
                work = random.choice(special_works)
            else:
                # 70% шанс сгенерировать новую работу
                verb = random.choice(self.work_verbs)
                obj = random.choice(self.work_objects)
                
                # 40% шанс добавить условие
                if random.random() < 0.4:
                    condition = random.choice(self.work_conditions)
                    work = f"{verb} {obj} {condition}"
                else:
                    work = f"{verb} {obj}"
                
                # 30% шанс добавить локацию
                if random.random() < 0.3:
                    location = random.choice(self.work_locations)
                    work += f" {location}"
            
            # Проверяем, не повторяется ли работа
            if work not in self.recent_works:
                # Добавляем в список недавних работ
                self.recent_works.append(work)
                if len(self.recent_works) > self.max_recent_works:
                    self.recent_works.pop(0)  # Удаляем самую старую
                return work
        
        # Если не удалось избежать повторений, возвращаем случайную работу
        logger.warning("Не удалось избежать повторений в generate_work_type")
        return work

    def generate_message(self):
        """Генерирует сообщение в стиле примеров с предотвращением коллизий"""
        max_attempts = 30  # Максимум попыток для избежания бесконечного цикла
        
        for attempt in range(max_attempts):
            work = self.generate_work_type()
            price = random.choice(self.prices)
            bonus = random.choice(self.bonuses)
            
            # Формируем сообщение в стиле примеров
            message = f"{work}, {price} {bonus}"

            # Сохраняем ключевые слова ДО искажения текста
            self.last_keywords = self.extract_keywords_from_work(work)
            
            # 80% шанс добавить дополнительную информацию
            if random.random() < 0.8:
                extra = random.choice(self.extra_info)
                message += f", {extra}"
            
            # 60% шанс добавить еще одну дополнительную информацию
            if random.random() < 0.6:
                extra2 = random.choice(self.extra_info)
                message += f", {extra2}"
            
            # 40% шанс добавить P.S. с угаром
            if random.random() < 0.4:
                quirky = random.choice(self.quirky_additions)
                message += f" {quirky}"
            
            # 30% шанс добавить еще один P.S.
            if random.random() < 0.3:
                quirky2 = random.choice(self.quirky_additions)
                message += f" {quirky2}"
            
            # Добавляем безграмотность в основной текст
            message = self.add_typos(message)
            
            # Делаем весь текст с маленькой буквы
            message = self.make_lowercase(message)
            
            # Проверяем, не повторяется ли сообщение
            if message not in self.recent_messages:
                # Добавляем в список недавних сообщений
                self.recent_messages.append(message)
                if len(self.recent_messages) > self.max_recent_messages:
                    self.recent_messages.pop(0)  # Удаляем самое старое
                return message
        
        # Если не удалось избежать повторений, возвращаем сообщение
        logger.warning("Не удалось избежать повторений в generate_message")
        return message

    def extract_keywords_from_work(self, work: str):
        """Выделяет ключевые слова-предметы из исходной фразы работы для ассоциативного поиска изображений."""
        try:
            text = work.lower()
            # Удаляем запятые/лишние символы
            for ch in [",", ".", "!", "?", ":", ";"]:
                text = text.replace(ch, " ")
            tokens = [t for t in text.split() if t]
            
            # Стоп-слова
            stop = {
                "в", "во", "на", "над", "под", "из", "от", "до", "за", "по", "для",
                "и", "или", "к", "с", "у", "о", "об", "про", "что", "как",
                "дня", "утра", "вечера", "ночью", "ночь", "днем", "день", "дома",
                "грязи", "пыли", "мусора", "листьев", "снега", "льда", "ржавчины"
            }
            
            # Словарь предметов для ассоциативного поиска
            object_keywords = {
                # Инструменты
                "отвертки": "screwdriver", "отвертка": "screwdriver", "ключей": "wrench", "ключи": "wrench",
                "молоток": "hammer", "молотки": "hammer", "плоскогубцы": "pliers", "ножовку": "saw",
                "ножовка": "saw", "дрель": "drill", "перфоратор": "drill", "болгарка": "grinder",
                "лопату": "shovel", "лопата": "shovel", "грабли": "rake", "ведро": "bucket",
                "швабру": "mop", "швабра": "mop", "тряпки": "rag", "тряпка": "rag",
                
                # Предметы мебели/интерьера
                "скамейку": "bench", "скамейка": "bench", "лавочку": "bench", "лавочка": "bench",
                "стул": "chair", "стулья": "chair", "кресло": "chair", "кресла": "chair",
                "диван": "sofa", "диваны": "sofa", "кровать": "bed", "кровати": "bed",
                "стол": "table", "столы": "table", "шкаф": "wardrobe", "шкафы": "wardrobe",
                
                # Строительные материалы/объекты
                "забор": "fence", "заборчик": "fence", "ворота": "gate", "калитку": "gate",
                "калитка": "gate", "лестницу": "stairs", "лестница": "stairs", "крышу": "roof",
                "крыша": "roof", "стены": "wall", "стена": "wall", "полы": "floor", "пол": "floor",
                "окна": "window", "окно": "window", "двери": "door", "дверь": "door",
                
                # Техника
                "машину": "car", "машина": "car", "велосипед": "bicycle", "веласипед": "bicycle",
                "телевизор": "tv", "компьютер": "computer", "холодильник": "refrigerator",
                "стиральную машину": "washing machine", "посудомойку": "dishwasher",
                
                # Другие предметы
                "посуду": "dishes", "посуда": "dishes", "ковры": "carpet", "ковер": "carpet",
                "шторы": "curtains", "штора": "curtains", "люстру": "chandelier", "люстра": "chandelier",
                "зеркала": "mirror", "зеркало": "mirror", "книги": "books", "книга": "books"
            }
            
            keywords = []
            
            # Ищем предметы в тексте
            for tok in tokens:
                if tok in object_keywords and tok not in keywords:
                    keywords.append(object_keywords[tok])
                    if len(keywords) >= 2:  # Максимум 2 предмета
                        break
            
            # Если не нашли предметы, ищем общие слова
            if not keywords:
                for tok in tokens:
                    if tok not in stop and tok.isalpha() and len(tok) > 3:
                        keywords.append(tok)
                        if len(keywords) >= 2:
                            break
            
            return keywords[:2]  # Возвращаем максимум 2 ключевых слова
            
        except Exception:
            return []
    
    def add_typos(self, text):
        """Добавляет МАКСИМАЛЬНУЮ безграмотность как у очень неграмотного человека"""
        # Словарь замен для МАКСИМАЛЬНОЙ безграмотности
        replacements = {
            "Покрасить": "Пакрасить",
            "Помыть": "Памыйть", 
            "Убрать": "Убрать",
            "Покосить": "Пакосить",
            "Посидеть": "Пасидеть",
            "Разобрать": "Разобрать",
            "Покормить": "Пакормить",
            "такси": "такси",
            "обед": "обед",
            "инвентарь": "инвентарь",
            "материалы": "матёриалы",
            "инструмент": "инструмент",
            "дюбелей": "дюбелёй",
            "перфоратор": "перфаратор",
            "болгарка": "болгарка",
            "дрель": "дрель",
            "ключей": "ключёй",
            "молоток": "молоток",
            "отвертки": "отвёртки",
            "плоскогубцы": "плоскогубцы",
            "ножовку": "ножовку",
            "лопату": "лопату",
            "грабли": "грабли",
            "ведро": "ведро",
            "тряпки": "тряпки",
            "швабру": "швабру",
            "забор": "забор",
            "бабушкой": "бабушкой",
            "крыльцо": "крыльцо",
            "мусора": "мусора",
            "дом": "дом",
            "грязи": "грязи",
            "снег": "снёг",
            "крыши": "крышй",
            "машину": "машину",
            "траву": "траву",
            "стены": "стены",
            "участке": "участке",
            "окна": "окна",
            "ворота": "ворота",
            "листья": "листья",
            "полы": "полы",
            "заборчик": "заборчик",
            "дорожек": "дорожек",
            "посуду": "посуду",
            "лавочку": "лавочку",
            "подвале": "подвале",
            "двери": "двери",
            "калитку": "калитку",
            "кота": "кота",
            "велосипед": "веласипед",
            "скамейку": "скамейку",
            "паутину": "паутину",
            "потолка": "потолка",
            "зеркала": "зеркала",
            "почтовый": "почтовый",
            "ящик": "ящик",
            "пыль": "пыль",
            "книг": "книг",
            "люстру": "люстру",
            "лестницу": "лестницу",
            "сарая": "сарая",
            "гараже": "гараже",
            "трубы": "труби",
            "подъезд": "подъезд",
            # Добавляем замены для ответных сообщений
            "сделали": "сдёлали",
            "готово": "гатово",
            "выполнили": "выполнйли",
            "спасибо": "спасиба",
            "работали": "рабаталй",
            "качественно": "качественна",
            "быстро": "быстра",
            "хорошо": "харашо"
        }
        
        # Применяем замены с вероятностью 70% (МАКСИМАЛЬНАЯ безграмотность)
        for correct, wrong in replacements.items():
            if random.random() < 0.7:
                text = text.replace(correct, wrong)
        
        # Добавляем МАКСИМАЛЬНО случайные опечатки
        if random.random() < 0.6:
            text = text.replace("и", "й", 1)
        if random.random() < 0.5:
            text = text.replace("е", "ё", 1)
        if random.random() < 0.4:
            text = text.replace("о", "а", 1)
        if random.random() < 0.35:
            text = text.replace("ы", "и", 1)
        if random.random() < 0.3:
            text = text.replace("у", "ю", 1)
        if random.random() < 0.25:
            text = text.replace("а", "о", 1)
        if random.random() < 0.2:
            text = text.replace("ё", "е", 1)
        if random.random() < 0.15:
            text = text.replace("й", "и", 1)
            
        return text

    def make_lowercase(self, text):
        """Делает весь текст с маленькой буквы"""
        return text.lower()

    def convert_to_personal_voice_style(self, text):
        """Конвертирует текст для голосового сообщения в сельском стиле с добавлением звуковых эффектов"""
        # Убираем лишние знаки препинания для лучшего произношения
        result = text.lower()
        
        # Заменяем ₽ на "рублей" для лучшего произношения
        result = result.replace("₽", " рублей")
        
        # Убираем лишние запятые, которые могут мешать произношению
        result = result.replace(",,", ",")
        result = result.replace(" ,", ",")
        
        # Добавляем сельские выражения
        rural_expressions = [
            "ну типа", "как бы", "вот так вот", "ну это", "как говорится", 
            "знаешь ли", "понимаешь", "слушай", "блин", "блин блинский",
            "ну бля", "ебать копать", "сука блядь", "ебать в рот",
            "блядь какая", "сука какая", "ебать какая", "блядская хуйня",
            "кстати", "между прочим", "к слову", "кстати говоря", "между нами говоря",
            "вообще-то", "в принципе", "так сказать", "в общем", "короче говоря"
        ]
        
        # 50% шанс добавить сельское выражение в начало
        if random.random() < 0.5:
            expression = random.choice(rural_expressions)
            result = f"{expression}, {result}"
        
        # 40% шанс добавить сельское выражение в середину
        if random.random() < 0.4:
            expression = random.choice(rural_expressions)
            words = result.split()
            if len(words) > 3:
                insert_pos = random.randint(1, len(words) - 1)
                words.insert(insert_pos, f", {expression},")
                result = " ".join(words)
        
        # Добавляем мат с высокой вероятностью для голосовых сообщений
        mat_insertions = [
            " бля,", " епты бля,", " ебать бля,", " блядь,", " епта,",
            " бляяя,", " ебать,", " бляха-муха,", " ептыть,", " блядски,",
            " ебаный насос,", " брали срали грелись,", " пизда рулю,", " вот сосалово,",
            " ебал мать,", " сын шлюхи,", " похуй плюс похуй,", " попердеть в хуй,",
            " нассать в глаза,", " кончал на носик сучке,", " сучка закрехтела,", " наквакал ей на писю,"
        ]
        
        # Добавляем мат в случайные места с высокой вероятностью
        if random.random() < 0.9:  # 90% шанс на мат
            mat_insertion = random.choice(mat_insertions)
            words = result.split()
            if len(words) > 2:
                insert_pos = random.randint(1, len(words) - 1)
                words.insert(insert_pos, mat_insertion.strip())
                result = " ".join(words)
        
        # Дополнительная вставка мата
        if random.random() < 0.7:  # 70% шанс на дополнительный мат
            mat_insertion2 = random.choice(mat_insertions)
            words = result.split()
            if len(words) > 4:
                insert_pos = random.randint(2, len(words) - 2)
                words.insert(insert_pos, mat_insertion2.strip())
                result = " ".join(words)
        
        # Добавляем характерные обращения в начало
        if random.random() < 0.6:  # 60% шанс
            start_words = ["ну, ", "братан, ", "земляк, ", "друг, ", "бля, ", "епты бля, ", "ебать бля, "]
            start_word = random.choice(start_words)
            result = start_word + result
        
        # Добавляем обращения в конец
        if random.random() < 0.5:  # 50% шанс
            end_words = [", братан", ", земляк", ", друг", ", бля", ", епты бля", ", ебать бля", ", блядь"]
            end_word = random.choice(end_words)
            result = result + end_word
        
        # Добавляем эмоциональные усилители
        if random.random() < 0.4:  # 40% шанс
            amplifiers = [" очень", " сильно", " реально", " конкретно", " блядски", " ебано", " бляяя"]
            amplifier = random.choice(amplifiers)
            words = result.split()
            if words:
                word_pos = random.randint(0, len(words) - 1)
                words[word_pos] = f"{amplifier} {words[word_pos]}"
                result = " ".join(words)
        
        # Добавляем паузы для более естественной речи
        if random.random() < 0.3:  # 30% шанс
            pause_insertions = [" ... ", " э-э-э ", " ммм "]
            pause = random.choice(pause_insertions)
            words = result.split()
            if len(words) > 3:
                insert_pos = random.randint(1, len(words) - 2)
                words.insert(insert_pos, pause.strip())
                result = " ".join(words)
        
        # Убираем двойные пробелы
        result = result.replace("  ", " ")
        result = result.replace("   ", " ")
        
        return result.strip()

    def improve_russian_pronunciation(self, text):
        """Улучшает русское произношение для ElevenLabs - читается 1в1 как текст"""
        # Замены для лучшего произношения русских слов
        pronunciation_fixes = {
            # Убираем лишние запятые, которые могут сбивать произношение
            ",,": ",",
            " ,": ",",
            ", ": ", ",
            
            # Добавляем пробелы после знаков препинания
            "₽": " рублей",
            
            # Исправляем потенциальные проблемы с произношением
            "блядь блядь": "блядь",
            "епты бля": "епты бля",
            "ебать бля": "ебать бля",
            "бляяя": "бляяя",
            "епта": "епта",
            "бляха-муха": "бляха-муха",
            "ептыть": "ептыть",
            "блядски": "блядски",
            "ебано": "ебано",
            
            # Убираем двойные пробелы
            "  ": " ",
            "   ": " ",
            "    ": " "
        }
        
        result = text
        for old, new in pronunciation_fixes.items():
            result = result.replace(old, new)
        
        # Убираем лишние пробелы в начале и конце
        result = result.strip()
        
        return result

    def add_real_sound_effects(self, audio_file_path):
        """Добавляет реальные звуковые эффекты к аудио файлу"""
        try:
            import pydub
            from pydub import AudioSegment
            from pydub.effects import normalize
            
            # Загружаем основное аудио
            main_audio = AudioSegment.from_mp3(audio_file_path)
            
            # Создаем звуковые эффекты программно
            sound_effects = {
                "БУУУУРП": self.create_burp_sound(),
                "БУРП": self.create_burp_sound(short=True),
                "ПУУУУК": self.create_fart_sound(),
                "ПУК": self.create_fart_sound(short=True),
                "СНОРРР": self.create_sniff_sound(),
                "ХАРРР": self.create_cough_sound(),
                "КХА-КХА": self.create_cough_sound(double=True),
                "АПЧХИ": self.create_sneeze_sound(),
                "ИК": self.create_hickup_sound()
            }
            
            # Добавляем случайные звуковые эффекты
            if random.random() < 0.7:  # 70% шанс добавить эффект
                effect_name = random.choice(list(sound_effects.keys()))
                effect_audio = sound_effects[effect_name]
                
                # Вставляем эффект в случайное место
                insert_pos = random.randint(1000, len(main_audio) - 1000)  # В миллисекундах
                main_audio = main_audio[:insert_pos] + effect_audio + main_audio[insert_pos:]
            
            # Сохраняем результат
            main_audio.export(audio_file_path, format="mp3")
            logger.info(f"✅ Добавлены реальные звуковые эффекты в {audio_file_path}")
            
        except ImportError:
            logger.warning("⚠️ pydub не установлен, звуковые эффекты пропущены")
        except Exception as e:
            logger.error(f"❌ Ошибка при добавлении звуковых эффектов: {e}")

    def create_burp_sound(self, short=False):
        """Создает звук рыгания"""
        try:
            import pydub
            from pydub import AudioSegment
            import numpy as np
            
            # Создаем звук рыгания (низкочастотный шум)
            duration = 500 if short else 1000  # миллисекунды
            sample_rate = 44100
            
            # Генерируем низкочастотный шум
            t = np.linspace(0, duration/1000, int(sample_rate * duration/1000))
            frequency = 80 + np.random.normal(0, 10)  # Низкая частота для рыгания
            
            # Создаем звук с затуханием
            wave = np.sin(2 * np.pi * frequency * t) * np.exp(-t * 3)
            wave = wave * 0.3  # Уменьшаем громкость
            
            # Конвертируем в AudioSegment
            audio_data = (wave * 32767).astype(np.int16)
            audio_segment = AudioSegment(
                audio_data.tobytes(),
                frame_rate=sample_rate,
                sample_width=2,
                channels=1
            )
            
            return audio_segment
            
        except Exception as e:
            logger.error(f"❌ Ошибка создания звука рыгания: {e}")
            return AudioSegment.silent(duration=100)

    def create_fart_sound(self, short=False):
        """Создает звук пердежа"""
        try:
            import pydub
            from pydub import AudioSegment
            import numpy as np
            
            duration = 300 if short else 800
            sample_rate = 44100
            
            # Создаем звук пердежа (белый шум с фильтром)
            t = np.linspace(0, duration/1000, int(sample_rate * duration/1000))
            
            # Белый шум
            noise = np.random.normal(0, 0.1, len(t))
            
            # Применяем фильтр для звука пердежа
            filtered_noise = noise * np.exp(-t * 2)
            
            # Конвертируем в AudioSegment
            audio_data = (filtered_noise * 16383).astype(np.int16)
            audio_segment = AudioSegment(
                audio_data.tobytes(),
                frame_rate=sample_rate,
                sample_width=2,
                channels=1
            )
            
            return audio_segment
            
        except Exception as e:
            logger.error(f"❌ Ошибка создания звука пердежа: {e}")
            return AudioSegment.silent(duration=100)

    def create_sniff_sound(self):
        """Создает звук сморкания"""
        try:
            import pydub
            from pydub import AudioSegment
            import numpy as np
            
            duration = 400
            sample_rate = 44100
            
            # Создаем звук сморкания (высокочастотный шум)
            t = np.linspace(0, duration/1000, int(sample_rate * duration/1000))
            frequency = 2000 + np.random.normal(0, 200)
            
            wave = np.sin(2 * np.pi * frequency * t) * np.exp(-t * 4)
            wave = wave * 0.2
            
            audio_data = (wave * 16383).astype(np.int16)
            audio_segment = AudioSegment(
                audio_data.tobytes(),
                frame_rate=sample_rate,
                sample_width=2,
                channels=1
            )
            
            return audio_segment
            
        except Exception as e:
            logger.error(f"❌ Ошибка создания звука сморкания: {e}")
            return AudioSegment.silent(duration=100)

    def create_cough_sound(self, double=False):
        """Создает звук кашля"""
        try:
            import pydub
            from pydub import AudioSegment
            import numpy as np
            
            duration = 600 if double else 300
            sample_rate = 44100
            
            # Создаем звук кашля
            t = np.linspace(0, duration/1000, int(sample_rate * duration/1000))
            
            # Комбинация частот для кашля
            wave1 = np.sin(2 * np.pi * 150 * t) * 0.3
            wave2 = np.sin(2 * np.pi * 300 * t) * 0.2
            wave3 = np.random.normal(0, 0.1, len(t)) * 0.1
            
            combined_wave = (wave1 + wave2 + wave3) * np.exp(-t * 2)
            
            if double:
                # Двойной кашель
                combined_wave = np.concatenate([combined_wave, np.zeros(int(sample_rate * 0.1)), combined_wave])
            
            audio_data = (combined_wave * 16383).astype(np.int16)
            audio_segment = AudioSegment(
                audio_data.tobytes(),
                frame_rate=sample_rate,
                sample_width=2,
                channels=1
            )
            
            return audio_segment
            
        except Exception as e:
            logger.error(f"❌ Ошибка создания звука кашля: {e}")
            return AudioSegment.silent(duration=100)

    def create_sneeze_sound(self):
        """Создает звук чихания"""
        try:
            import pydub
            from pydub import AudioSegment
            import numpy as np
            
            duration = 800
            sample_rate = 44100
            
            # Создаем звук чихания
            t = np.linspace(0, duration/1000, int(sample_rate * duration/1000))
            
            # Высокочастотный звук с резким началом
            frequency = 1000 + np.random.normal(0, 100)
            wave = np.sin(2 * np.pi * frequency * t)
            
            # Резкое начало и затухание
            envelope = np.concatenate([
                np.linspace(0, 1, int(sample_rate * 0.05)),  # Резкое начало
                np.exp(-t[int(sample_rate * 0.05):] * 5)     # Затухание
            ])
            
            wave = wave * envelope * 0.3
            
            audio_data = (wave * 16383).astype(np.int16)
            audio_segment = AudioSegment(
                audio_data.tobytes(),
                frame_rate=sample_rate,
                sample_width=2,
                channels=1
            )
            
            return audio_segment
            
        except Exception as e:
            logger.error(f"❌ Ошибка создания звука чихания: {e}")
            return AudioSegment.silent(duration=100)

    def create_hickup_sound(self):
        """Создает звук икоты"""
        try:
            import pydub
            from pydub import AudioSegment
            import numpy as np
            
            duration = 200
            sample_rate = 44100
            
            # Создаем звук икоты
            t = np.linspace(0, duration/1000, int(sample_rate * duration/1000))
            frequency = 120 + np.random.normal(0, 20)
            
            wave = np.sin(2 * np.pi * frequency * t) * np.exp(-t * 8)
            wave = wave * 0.4
            
            audio_data = (wave * 16383).astype(np.int16)
            audio_segment = AudioSegment(
                audio_data.tobytes(),
                frame_rate=sample_rate,
                sample_width=2,
                channels=1
            )
            
            return audio_segment
            
        except Exception as e:
            logger.error(f"❌ Ошибка создания звука икоты: {e}")
            return AudioSegment.silent(duration=100)

    def generate_completion_message(self):
        """Генерирует ответное сообщение от работодателя о том, что работа выполнена"""
        # Выбираем основную фразу
        main_phrase = random.choice(self.completion_phrases)
        
        # 30% шанс добавить тупой подарок
        if random.random() < 0.3:
            detail = random.choice(self.completion_details)
            message = f"{main_phrase}, {detail}"
        else:
            message = main_phrase
        
        # Добавляем безграмотность
        message = self.add_typos(message)
        
        # Делаем весь текст с маленькой буквы
        message = self.make_lowercase(message)
        
        return message

    def generate_voice_message(self, text):
        """Генерирует голосовое сообщение с сельским стилем и звуковыми эффектами"""
        try:
            # Конвертируем текст для голосового сообщения (читается 1в1 с матом)
            personal_text = self.convert_to_personal_voice_style(text)
            
            # Добавляем звуковые эффекты (80% шанс)
            if random.random() < 0.8:
                # Реальные звуковые эффекты (будут добавлены в аудио)
                sound_effects = [
                    # Рыгание - реальные звуки
                    " *БУУУУРП* ", " *БУРП* ", " *БУУУРП* ", " *БУРП-БУРП* ",
                    # Сморкание - реальные звуки  
                    " *СНОРРР* ", " *СНОР* ", " *СНОРРРР* ", " *СНОР-СНОР* ",
                    # Отхаркивание - реальные звуки
                    " *ХАРРР* ", " *ХАР* ", " *ХАРРРР* ", " *ХАР-ХАР* ",
                    # Пердеж - реальные звуки
                    " *ПУУУУК* ", " *ПУК* ", " *ПУУУУК* ", " *ПУК-ПУК* ",
                    # Кашель - реальные звуки
                    " *КХА-КХА* ", " *КХА* ", " *КХА-КХА-КХА* ", " *КХААА* ",
                    # Другие эффекты - реальные звуки
                    " *ИК* ", " *АПЧХИ* ", " *ЗЕВ* ", " *ВЗДОХ* ",
                    " *МУУ* ", " *КРЯХ* ", " *ХМ* ", " *СОП* ",
                    " *ХРЮ* ", " *КРЯ* ", " *МУ* ", " *МУ* ",
                    # Театральные эффекты
                    " *ПАУЗА* ", " *ШЕПОТ* ", " *ГРОМКО* ", " *ТИХО* ", " *КРИК* "
                ]
                effect = random.choice(sound_effects)
                # Вставляем эффект в случайное место
                words = personal_text.split()
                if len(words) > 2:
                    insert_pos = random.randint(1, len(words) - 1)
                    words.insert(insert_pos, effect)
                    personal_text = " ".join(words)
                
                # 50% шанс добавить второй звуковой эффект
                if random.random() < 0.5:
                    effect2 = random.choice(sound_effects)
                    words = personal_text.split()
                    if len(words) > 3:
                        insert_pos2 = random.randint(1, len(words) - 1)
                        words.insert(insert_pos2, effect2)
                        personal_text = " ".join(words)
            
            # Улучшаем русское произношение
            personal_text = self.improve_russian_pronunciation(personal_text)
            
            logger.info(f"Текст для озвучки (с матом и эффектами): {personal_text}")
            
            # Используем ElevenLabs если доступен
            if self.elevenlabs_client and ELEVENLABS_VOICE_ID:
                logger.info("🎤 Используем ElevenLabs для генерации голоса")
                
                # Генерируем аудио с помощью ElevenLabs (оптимизировано для русского)
                audio = self.elevenlabs_client.text_to_speech.convert(
                    text=personal_text,
                    voice_id=ELEVENLABS_VOICE_ID,
                    model_id="eleven_multilingual_v2",  # Многоязычная модель для русского
                    output_format="mp3_44100_128",
                    voice_settings={
                        "stability": 0.8,  # Высокая стабильность для четкого произношения
                        "similarity_boost": 0.9,  # Максимальное сходство с оригиналом
                        "style": 0.1,  # Минимальный стиль для естественного звучания
                        "use_speaker_boost": True  # Усиление голоса говорящего
                    }
                )
                
                # Сохраняем во временный файл
                temp_audio = tempfile.NamedTemporaryFile(delete=False, suffix='.mp3')
                # Конвертируем generator в bytes
                audio_bytes = b''.join(audio)
                temp_audio.write(audio_bytes)
                temp_audio.close()
                
                # Добавляем реальные звуковые эффекты
                self.add_real_sound_effects(temp_audio.name)
                
                logger.info(f"✅ Голосовое сообщение создано с ElevenLabs: {temp_audio.name}")
                return temp_audio.name
                
            else:
                # Фоллбек на gTTS если ElevenLabs недоступен
                logger.warning("⚠️ ElevenLabs недоступен, используем gTTS")
                return self._generate_voice_with_gtts(personal_text)
            
        except Exception as e:
            logger.error(f"❌ Ошибка при создании голосового сообщения: {e}")
            # Фоллбек на gTTS при ошибке
            try:
                personal_text = self.convert_to_personal_voice_style(text)
                personal_text = self.improve_russian_pronunciation(personal_text)
                return self._generate_voice_with_gtts(personal_text)
            except Exception as e2:
                logger.error(f"❌ Критическая ошибка в фоллбеке: {e2}")
                return None
    
    def _generate_voice_with_gtts(self, text):
        """Фоллбек метод для генерации голоса с помощью gTTS"""
        try:
            from gtts import gTTS
            
            # Создаем TTS с русским языком
            tts = gTTS(text=text, lang='ru', slow=False)
            
            # Сохраняем во временный файл
            temp_audio = tempfile.NamedTemporaryFile(delete=False, suffix='.mp3')
            tts.save(temp_audio.name)
            temp_audio.close()
            
            logger.info(f"✅ Голосовое сообщение создано с gTTS (фоллбек): {temp_audio.name}")
            return temp_audio.name
            
        except Exception as e:
            logger.error(f"❌ Ошибка в gTTS фоллбеке: {e}")
            return None

    def search_churka_image(self):
        """Фоллбек: изображения с дагестанцами, таджиками и подобными."""
        try:
            # Готовые URL изображений с нужными людьми
            ethnic_people_urls = [
                # Unsplash - рабочие, строители, мигранты
                "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=400&fit=crop&crop=face",
                "https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=400&h=400&fit=crop&crop=face",
                "https://images.unsplash.com/photo-1500648767791-00dcc994a43e?w=400&h=400&fit=crop&crop=face",
                "https://images.unsplash.com/photo-1506794778202-cad84cf45f1d?w=400&h=400&fit=crop&crop=face",
                "https://images.unsplash.com/photo-1519345182560-3f2917c472ef?w=400&h=400&fit=crop&crop=face",
                "https://images.unsplash.com/photo-1507591064344-4c6ce005b128?w=400&h=400&fit=crop&crop=face",
                "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=400&fit=crop&crop=face",
                "https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=400&h=400&fit=crop&crop=face",
                "https://images.unsplash.com/photo-1500648767791-00dcc994a43e?w=400&h=400&fit=crop&crop=face",
                "https://images.unsplash.com/photo-1506794778202-cad84cf45f1d?w=400&h=400&fit=crop&crop=face",
                "https://images.unsplash.com/photo-1519345182560-3f2917c472ef?w=400&h=400&fit=crop&crop=face",
                "https://images.unsplash.com/photo-1507591064344-4c6ce005b128?w=400&h=400&fit=crop&crop=face",
                # Picsum с фиксированными ID для стабильности
                "https://picsum.photos/400/400?random=300",
                "https://picsum.photos/400/400?random=301", 
                "https://picsum.photos/400/400?random=302",
                "https://picsum.photos/400/400?random=303",
                "https://picsum.photos/400/400?random=304",
                "https://picsum.photos/400/400?random=305",
                "https://picsum.photos/400/400?random=306",
                "https://picsum.photos/400/400?random=307",
                "https://picsum.photos/400/400?random=308",
                "https://picsum.photos/400/400?random=309",
                "https://picsum.photos/400/400?random=310"
            ]
            
            selected_url = random.choice(ethnic_people_urls)
            logger.info(f"Выбрано изображение (fallback с дагестанцем/таджиком): {selected_url}")
            return selected_url
        except Exception as e:
            logger.error(f"Ошибка при выборе изображения: {e}")
            return None

    def fetch_unsplash_image(self, keywords):
        """Ищет ассоциативные изображения на Unsplash по предметам из текста."""
        try:
            if not UNSPLASH_API_KEY:
                return None
            
            # Если есть ключевые слова-предметы, ищем их
            if keywords:
                for keyword in keywords:
                    try:
                        url = f"https://api.unsplash.com/search/photos"
                        headers = {"Authorization": f"Client-ID {UNSPLASH_API_KEY}"}
                        params = {
                            "query": keyword,
                            "per_page": 20,
                            "orientation": "all"
                        }
                        resp = requests.get(url, headers=headers, params=params, timeout=10)
                        resp.raise_for_status()
                        data = resp.json()
                        results = data.get("results", [])
                        if results:
                            result = random.choice(results)
                            image_url = result.get("urls", {}).get("regular")
                            if image_url:
                                logger.info(f"Найдено ассоциативное изображение '{keyword}' на Unsplash: {image_url}")
                                return image_url
                    except Exception as e:
                        logger.warning(f"Ошибка поиска '{keyword}' на Unsplash: {e}")
                        continue
            
            # Фоллбек: поиск рабочих/строителей
            fallback_queries = [
                "construction worker", "migrant worker", "laborer", "manual worker", "dirty worker",
                "construction man", "worker face", "laborer face", "manual labor", "dirty man"
            ]
            
            for query in fallback_queries:
                try:
                    url = f"https://api.unsplash.com/search/photos"
                    headers = {"Authorization": f"Client-ID {UNSPLASH_API_KEY}"}
                    params = {
                        "query": query,
                        "per_page": 20,
                        "orientation": "portrait"
                    }
                    resp = requests.get(url, headers=headers, params=params, timeout=10)
                    resp.raise_for_status()
                    data = resp.json()
                    results = data.get("results", [])
                    if results:
                        result = random.choice(results)
                        image_url = result.get("urls", {}).get("regular")
                        if image_url:
                            logger.info(f"Найдено изображение рабочего по запросу '{query}': {image_url}")
                            return image_url
                except Exception as e:
                    logger.warning(f"Ошибка поиска по запросу '{query}': {e}")
                    continue
            
            logger.warning("Не найдено подходящих изображений на Unsplash")
            return None
            
        except Exception as e:
            logger.warning(f"Unsplash недоступен или вернул ошибку: {e}")
            return None

    def fetch_pexels_image(self, keywords):
        """Ищет ассоциативные изображения на Pexels по предметам из текста."""
        try:
            if not PEXELS_API_KEY:
                return None
            
            # Если есть ключевые слова-предметы, ищем их
            if keywords:
                for keyword in keywords:
                    try:
                        url = f"https://api.pexels.com/v1/search"
                        headers = {"Authorization": PEXELS_API_KEY}
                        params = {
                            "query": keyword,
                            "per_page": 20,
                            "orientation": "all"
                        }
                        resp = requests.get(url, headers=headers, params=params, timeout=10)
                        resp.raise_for_status()
                        data = resp.json()
                        photos = data.get("photos", [])
                        if photos:
                            photo = random.choice(photos)
                            image_url = photo.get("src", {}).get("medium")
                            if image_url:
                                logger.info(f"Найдено ассоциативное изображение '{keyword}' на Pexels: {image_url}")
                                return image_url
                    except Exception as e:
                        logger.warning(f"Ошибка поиска '{keyword}' на Pexels: {e}")
                        continue
            
            # Фоллбек: поиск рабочих/строителей
            fallback_queries = [
                "construction worker", "migrant worker", "laborer", "manual worker", "dirty worker",
                "construction man", "worker face", "laborer face", "manual labor", "dirty man"
            ]
            
            for query in fallback_queries:
                try:
                    url = f"https://api.pexels.com/v1/search"
                    headers = {"Authorization": PEXELS_API_KEY}
                    params = {
                        "query": query,
                        "per_page": 20,
                        "orientation": "portrait"
                    }
                    resp = requests.get(url, headers=headers, params=params, timeout=10)
                    resp.raise_for_status()
                    data = resp.json()
                    photos = data.get("photos", [])
                    if photos:
                        photo = random.choice(photos)
                        image_url = photo.get("src", {}).get("medium")
                        if image_url:
                            logger.info(f"Найдено изображение рабочего по запросу '{query}': {image_url}")
                            return image_url
                except Exception as e:
                    logger.warning(f"Ошибка поиска по запросу '{query}': {e}")
                    continue
            
            logger.warning("Не найдено подходящих изображений на Pexels")
            return None
            
        except Exception as e:
            logger.warning(f"Pexels недоступен или вернул ошибку: {e}")
            return None

    def fetch_pixabay_image(self, keywords):
        """Ищет ассоциативные изображения на Pixabay по предметам из текста."""
        try:
            if not PIXABAY_API_KEY:
                return None
            
            # Если есть ключевые слова-предметы, ищем их
            if keywords:
                for keyword in keywords:
                    try:
                        # Заменяем пробелы на + для Pixabay
                        query = keyword.replace(" ", "+")
                        url = (
                            f"https://pixabay.com/api/?key={PIXABAY_API_KEY}"
                            f"&q={query}&image_type=photo&lang=en&safesearch=true&per_page=20&orientation=all"
                        )
                        resp = requests.get(url, timeout=10)
                        resp.raise_for_status()
                        data = resp.json()
                        hits = data.get("hits", [])
                        if hits:
                            hit = random.choice(hits)
                            image_url = hit.get("webformatURL") or hit.get("largeImageURL")
                            if image_url:
                                logger.info(f"Найдено ассоциативное изображение '{keyword}' на Pixabay: {image_url}")
                                return image_url
                    except Exception as e:
                        logger.warning(f"Ошибка поиска '{keyword}' на Pixabay: {e}")
                        continue
            
            # Фоллбек: поиск рабочих/строителей
            fallback_queries = [
                "dirty+worker", "construction+worker", "migrant+worker", "laborer", "manual+worker",
                "dirty+man", "construction+man", "worker+face", "laborer+face", "manual+labor"
            ]
            
            for query in fallback_queries:
                try:
                    url = (
                        f"https://pixabay.com/api/?key={PIXABAY_API_KEY}"
                        f"&q={query}&image_type=photo&lang=en&safesearch=true&per_page=20&orientation=horizontal"
                    )
                    resp = requests.get(url, timeout=10)
                    resp.raise_for_status()
                    data = resp.json()
                    hits = data.get("hits", [])
                    if hits:
                        hit = random.choice(hits)
                        image_url = hit.get("webformatURL") or hit.get("largeImageURL")
                        if image_url:
                            logger.info(f"Найдено изображение рабочего по запросу '{query}': {image_url}")
                            return image_url
                except Exception as e:
                    logger.warning(f"Ошибка поиска по запросу '{query}': {e}")
                    continue
            
            logger.warning("Не найдено подходящих изображений на Pixabay")
            return None
            
        except Exception as e:
            logger.warning(f"Pixabay недоступен или вернул ошибку: {e}")
            return None

    def get_funny_images_for_message(self):
        """Возвращает список URL смешных изображений для прикрепления к посту (2-3 штуки)"""
        funny_keywords = [
            "funny construction worker", "meme builder", "laughing worker", "funny handyman",
            "construction worker meme", "funny laborer", "meme construction", "laughing builder",
            "funny repairman", "meme handyman", "laughing repairman", "funny maintenance",
            "construction worker funny", "builder meme", "handyman funny", "worker meme",
            "funny contractor", "meme contractor", "laughing contractor", "funny tradesman",
            "construction meme", "building meme", "repair meme", "maintenance meme",
            "funny tools", "meme tools", "laughing tools", "funny equipment",
            "construction funny", "building funny", "repair funny", "maintenance funny"
        ]
        
        images = []
        
        # Пробуем найти 2-3 смешных изображения
        for i in range(3):
            try:
                # Используем случайные ключевые слова для разнообразия
                keyword = random.choice(funny_keywords)
                
                # Пробуем разные источники
                url = None
                if i == 0:
                    url = self.fetch_unsplash_image([keyword])
                elif i == 1:
                    url = self.fetch_pexels_image([keyword])
                else:
                    url = self.fetch_pixabay_image([keyword])
                
                if url and url not in images:
                    images.append(url)
                    logger.info(f"Найдено смешное изображение {i+1}: {url}")
                
                # Если не нашли, используем fallback
                if not url:
                    fallback_url = self.search_churka_image()
                    if fallback_url and fallback_url not in images:
                        images.append(fallback_url)
                        logger.info(f"Используется fallback смешное изображение {i+1}: {fallback_url}")
                
            except Exception as e:
                logger.warning(f"Ошибка при поиске смешного изображения {i+1}: {e}")
                continue
        
        # Если не нашли достаточно изображений, добавляем случайные
        while len(images) < 2:
            random_url = f"https://picsum.photos/400/400?random={random.randint(1000, 9999)}"
            if random_url not in images:
                images.append(random_url)
                logger.info(f"Добавлено случайное изображение: {random_url}")
        
        # Возвращаем максимум 3 изображения
        return images[:3]

    def get_image_for_message(self):
        """Возвращает URL ассоциативного изображения по предметам из текста."""
        # Пробуем разные источники по очереди для поиска ассоциативных изображений
        
        # 1. Unsplash (лучший источник для ассоциативных изображений)
        url = self.fetch_unsplash_image(self.last_keywords)
        if url:
            logger.info(f"Найдено ассоциативное изображение на Unsplash по ключевым словам {self.last_keywords}: {url}")
            return url
        
        # 2. Pexels (хороший источник)
        url = self.fetch_pexels_image(self.last_keywords)
        if url:
            logger.info(f"Найдено ассоциативное изображение на Pexels по ключевым словам {self.last_keywords}: {url}")
            return url
        
        # 3. Pixabay (резерв)
        url = self.fetch_pixabay_image(self.last_keywords)
        if url:
            logger.info(f"Найдено ассоциативное изображение на Pixabay по ключевым словам {self.last_keywords}: {url}")
            return url
        
        # 4. Фоллбек: всегда изображения с дагестанцами/таджиками
        fallback_url = self.search_churka_image()
        if fallback_url:
            logger.info(f"Используется fallback изображение с дагестанцем/таджиком: {fallback_url}")
            return fallback_url
        
        # 5. Последний резерв - случайное изображение
        logger.warning("Используется последний резерв - случайное изображение")
        return "https://picsum.photos/400/400?random=999"

    def download_image(self, image_url):
        """Скачивает изображение по URL"""
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            
            response = requests.get(image_url, headers=headers, timeout=15)
            response.raise_for_status()
            
            # Проверяем размер файла (не больше 5MB)
            if len(response.content) > 5 * 1024 * 1024:
                logger.warning("Изображение слишком большое, пропускаем")
                return None
            
            # Создаем временный файл
            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.jpg')
            temp_file.write(response.content)
            temp_file.close()
            
            logger.info(f"Изображение скачано: {temp_file.name}")
            return temp_file.name
            
        except Exception as e:
            logger.error(f"Ошибка при скачивании изображения: {e}")
            return None

    async def send_message_with_photos_to_channel(self):
        """Отправляет сообщение с 2-3 смешными фотографиями"""
        message = self.generate_message()
        max_retries = 5
        
        # Получаем смешные изображения
        image_urls = self.get_funny_images_for_message()
        logger.info(f"Найдено {len(image_urls)} смешных изображений для поста")
        
        for attempt in range(max_retries):
            try:
                # Скачиваем изображения
                downloaded_images = []
                for url in image_urls:
                    try:
                        image_path = self.download_image(url)
                        if image_path:
                            downloaded_images.append(image_path)
                    except Exception as e:
                        logger.warning(f"Не удалось скачать изображение {url}: {e}")
                        continue
                
                if downloaded_images:
                    # Отправляем медиа-группу с фотографиями
                    media_group = []
                    for i, image_path in enumerate(downloaded_images):
                        try:
                            with open(image_path, 'rb') as photo:
                                if i == 0:
                                    # Первое фото с подписью
                                    media_group.append(InputMediaPhoto(media=photo, caption=message))
                                else:
                                    # Остальные фото без подписи
                                    media_group.append(InputMediaPhoto(media=photo))
                        except Exception as e:
                            logger.warning(f"Ошибка при подготовке фото {i+1}: {e}")
                            continue
                    
                    if media_group:
                        sent_messages = await asyncio.wait_for(
                            self.bot.send_media_group(chat_id=CHANNEL_ID, media=media_group),
                            timeout=60  # Больше времени для медиа-группы
                        )
                        # Сохраняем ID первого сообщения для reply
                        self.last_message_id = sent_messages[0].message_id
                        logger.info(f"✅ Сообщение с {len(downloaded_images)} фотографиями отправлено: {message}")
                        
                        # Удаляем временные файлы
                        for image_path in downloaded_images:
                            try:
                                os.unlink(image_path)
                            except:
                                pass
                        return
                
                # Если не удалось отправить с фото, отправляем обычный текст
                logger.warning("Не удалось отправить с фотографиями, отправляем обычный текст")
                await self.send_message_to_channel()
                return
                
            except asyncio.TimeoutError:
                logger.error(f"⏰ Таймаут отправки сообщения с фото (попытка {attempt + 1})")
                if attempt < max_retries - 1:
                    await asyncio.sleep(min(2 ** attempt, 30))
                continue
            except Exception as e:
                error_msg = str(e)
                logger.error(f"❌ Ошибка отправки сообщения с фото (попытка {attempt + 1}): {error_msg}")
                
                # Специальная обработка для ошибок event loop
                if "Event loop is closed" in error_msg or "RuntimeError" in error_msg:
                    logger.warning("🔄 Обнаружена ошибка закрытого event loop в сообщении с фото")
                    if attempt < max_retries - 1:
                        await asyncio.sleep(10)
                        # Создаем новый bot instance для следующей попытки
                        try:
                            new_request = HTTPXRequest(
                                connection_pool_size=5,
                                pool_timeout=20,
                                read_timeout=20,
                                write_timeout=20,
                                connect_timeout=20
                            )
                            self.bot = Bot(token=BOT_TOKEN, request=new_request)
                            logger.info("🔄 Создан новый bot instance для сообщения с фото")
                        except Exception as bot_e:
                            logger.error(f"❌ Ошибка создания нового bot instance: {bot_e}")
                
                if attempt < max_retries - 1:
                    await asyncio.sleep(min(2 ** attempt, 30))
                else:
                    logger.error(f"💀 Не удалось отправить сообщение с фото, отправляем обычный текст: {message}")
                    # Фоллбек на обычное текстовое сообщение
                    await self.send_message_to_channel()
                    return

    async def send_message_to_channel(self):
        """Отправляет только текстовое сообщение в канал с улучшенными повторными попытками"""
        message = self.generate_message()
        max_retries = 5  # Увеличиваем количество попыток
        
        for attempt in range(max_retries):
            try:
                # Отправляем только текст с таймаутом
                sent_message = await asyncio.wait_for(
                    self.bot.send_message(chat_id=CHANNEL_ID, text=message),
                    timeout=30  # 30 секунд таймаут на отправку
                )
                # Сохраняем ID сообщения для reply
                self.last_message_id = sent_message.message_id
                logger.info(f"✅ Текстовое сообщение отправлено: {message}")
                return
                    
            except asyncio.TimeoutError:
                logger.error(f"⏰ Таймаут отправки (попытка {attempt + 1})")
                if attempt < max_retries - 1:
                    await asyncio.sleep(min(2 ** attempt, 30))  # Максимум 30 секунд задержки
                continue
            except Exception as e:
                error_msg = str(e)
                logger.error(f"❌ Ошибка отправки (попытка {attempt + 1}): {error_msg}")
                
                # Специальная обработка для ошибок пула соединений
                if "Pool timeout" in error_msg or "connection pool" in error_msg.lower():
                    logger.warning("🔄 Обнаружена ошибка пула соединений, увеличиваем задержку")
                    if attempt < max_retries - 1:
                        await asyncio.sleep(min(5 * (2 ** attempt), 60))  # Больше времени для восстановления пула
                    continue
                
                # Специальная обработка для ошибок event loop
                if "Event loop is closed" in error_msg or "RuntimeError" in error_msg:
                    logger.warning("🔄 Обнаружена ошибка закрытого event loop")
                    if attempt < max_retries - 1:
                        await asyncio.sleep(10)  # Даем время на восстановление
                        # Создаем новый bot instance для следующей попытки
                        try:
                            new_request = HTTPXRequest(
                                connection_pool_size=5,
                                pool_timeout=20,
                                read_timeout=20,
                                write_timeout=20,
                                connect_timeout=20
                            )
                            self.bot = Bot(token=BOT_TOKEN, request=new_request)
                            logger.info("🔄 Создан новый bot instance")
                        except Exception as bot_e:
                            logger.error(f"❌ Ошибка создания нового bot instance: {bot_e}")
                    continue
                
                if attempt < max_retries - 1:
                    await asyncio.sleep(min(2 ** attempt, 30))  # Экспоненциальная задержка с ограничением
                else:
                    logger.error(f"💀 Не удалось отправить сообщение после {max_retries} попыток: {message}")
                    # Последняя попытка с новым bot instance
                    try:
                        # Создаем новый bot instance для последней попытки
                        new_request = HTTPXRequest(
                            connection_pool_size=10,
                            pool_timeout=30,
                            read_timeout=30,
                            write_timeout=30,
                            connect_timeout=30
                        )
                        emergency_bot = Bot(token=BOT_TOKEN, request=new_request)
                        await asyncio.wait_for(
                            emergency_bot.send_message(chat_id=CHANNEL_ID, text=message),
                            timeout=60
                        )
                        logger.info(f"🆘 Резервное сообщение отправлено: {message}")
                    except Exception as final_e:
                        logger.error(f"💀 Финальная ошибка: {final_e}")

    async def send_completion_message_to_channel(self, reply_to_message_id=None):
        """Отправляет ответное сообщение о том, что работа уже выполнена"""
        message = self.generate_completion_message()
        max_retries = 3
        
        # Если не указан reply_to_message_id, используем ID последнего сообщения
        if reply_to_message_id is None:
            reply_to_message_id = self.last_message_id
        
        for attempt in range(max_retries):
            try:
                # Отправляем сообщение с реплаем на предыдущее
                sent_message = await asyncio.wait_for(
                    self.bot.send_message(
                        chat_id=CHANNEL_ID, 
                        text=message,
                        reply_to_message_id=reply_to_message_id
                    ),
                    timeout=30
                )
                # Сохраняем ID ответного сообщения
                self.last_message_id = sent_message.message_id
                logger.info(f"✅ Ответное сообщение отправлено (reply to {reply_to_message_id}): {message}")
                return
                    
            except asyncio.TimeoutError:
                logger.error(f"⏰ Таймаут отправки ответного сообщения (попытка {attempt + 1})")
                if attempt < max_retries - 1:
                    await asyncio.sleep(min(2 ** attempt, 30))
                continue
            except Exception as e:
                error_msg = str(e)
                logger.error(f"❌ Ошибка отправки ответного сообщения (попытка {attempt + 1}): {error_msg}")
                
                # Специальная обработка для ошибок event loop
                if "Event loop is closed" in error_msg or "RuntimeError" in error_msg:
                    logger.warning("🔄 Обнаружена ошибка закрытого event loop в ответном сообщении")
                    if attempt < max_retries - 1:
                        await asyncio.sleep(10)
                        # Создаем новый bot instance для следующей попытки
                        try:
                            new_request = HTTPXRequest(
                                connection_pool_size=5,
                                pool_timeout=20,
                                read_timeout=20,
                                write_timeout=20,
                                connect_timeout=20
                            )
                            self.bot = Bot(token=BOT_TOKEN, request=new_request)
                            logger.info("🔄 Создан новый bot instance для ответного сообщения")
                        except Exception as bot_e:
                            logger.error(f"❌ Ошибка создания нового bot instance: {bot_e}")
                
                if attempt < max_retries - 1:
                    await asyncio.sleep(min(2 ** attempt, 30))
                else:
                    logger.error(f"💀 Не удалось отправить ответное сообщение: {message}")

    async def send_voice_message_to_channel(self):
        """Отправляет голосовое сообщение в канал с персональным стилем речи"""
        message = self.generate_message()
        max_retries = 3
        
        # Генерируем голосовое сообщение
        voice_file = self.generate_voice_message(message)
        if not voice_file:
            logger.error("Не удалось создать голосовое сообщение, отправляем текст")
            await self.send_message_to_channel()
            return
        
        for attempt in range(max_retries):
            try:
                # Отправляем голосовое сообщение
                with open(voice_file, 'rb') as voice:
                    sent_message = await asyncio.wait_for(
                        self.bot.send_voice(
                            chat_id=CHANNEL_ID, 
                            voice=voice,
                            caption=message.lower()  # Обычный текст без эмодзи и с маленькой буквы
                        ),
                        timeout=60  # Больше времени для голосовых сообщений
                    )
                # Сохраняем ID сообщения для reply
                self.last_message_id = sent_message.message_id
                logger.info(f"🎤 Голосовое сообщение отправлено: {message}")
                
                # Удаляем временный файл
                try:
                    os.unlink(voice_file)
                except:
                    pass
                return
                    
            except asyncio.TimeoutError:
                logger.error(f"⏰ Таймаут отправки голосового сообщения (попытка {attempt + 1})")
                if attempt < max_retries - 1:
                    await asyncio.sleep(min(2 ** attempt, 30))
                continue
            except Exception as e:
                error_msg = str(e)
                logger.error(f"❌ Ошибка отправки голосового сообщения (попытка {attempt + 1}): {error_msg}")
                
                # Специальная обработка для ошибок event loop
                if "Event loop is closed" in error_msg or "RuntimeError" in error_msg:
                    logger.warning("🔄 Обнаружена ошибка закрытого event loop в голосовом сообщении")
                    if attempt < max_retries - 1:
                        await asyncio.sleep(10)
                        # Создаем новый bot instance для следующей попытки
                        try:
                            new_request = HTTPXRequest(
                                connection_pool_size=5,
                                pool_timeout=20,
                                read_timeout=20,
                                write_timeout=20,
                                connect_timeout=20
                            )
                            self.bot = Bot(token=BOT_TOKEN, request=new_request)
                            logger.info("🔄 Создан новый bot instance для голосового сообщения")
                        except Exception as bot_e:
                            logger.error(f"❌ Ошибка создания нового bot instance: {bot_e}")
                
                if attempt < max_retries - 1:
                    await asyncio.sleep(min(2 ** attempt, 30))
                else:
                    logger.error(f"💀 Не удалось отправить голосовое сообщение, отправляем текст: {message}")
                    # Фоллбек на текстовое сообщение
                    try:
                        os.unlink(voice_file)
                    except:
                        pass
                    await self.send_message_to_channel()
                    return

    def send_message_with_photos_sync(self):
        """Синхронная обертка для отправки сообщения с фотографиями"""
        try:
            # Всегда создаем новый event loop для изоляции
            import concurrent.futures
            with concurrent.futures.ThreadPoolExecutor() as executor:
                future = executor.submit(self._run_photos_in_new_loop)
                future.result(timeout=180)  # 3 минуты таймаут для фото
        except Exception as e:
            logger.error(f"❌ Ошибка в send_message_with_photos_sync: {e}")
            # Последняя попытка с простым asyncio.run
            try:
                asyncio.run(self.send_message_with_photos_to_channel())
            except Exception as e2:
                logger.error(f"❌ Критическая ошибка в send_message_with_photos_sync: {e2}")
    
    def _run_photos_in_new_loop(self):
        """Запускает отправку сообщения с фото в новом event loop"""
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            loop.run_until_complete(self.send_message_with_photos_to_channel())
        except Exception as e:
            logger.error(f"❌ Ошибка в новом event loop для фото: {e}")
        finally:
            # Простое и безопасное закрытие loop
            try:
                loop.close()
            except Exception:
                pass

    def send_message_sync(self):
        """Синхронная обертка для отправки сообщения с упрощенным управлением event loop"""
        try:
            # Всегда создаем новый event loop для изоляции
            import concurrent.futures
            with concurrent.futures.ThreadPoolExecutor() as executor:
                future = executor.submit(self._run_in_new_loop)
                future.result(timeout=120)  # 2 минуты таймаут
        except Exception as e:
            logger.error(f"❌ Ошибка в send_message_sync: {e}")
            # Последняя попытка с простым asyncio.run
            try:
                asyncio.run(self.send_message_to_channel())
            except Exception as e2:
                logger.error(f"❌ Критическая ошибка в send_message_sync: {e2}")
    
    def _run_in_new_loop(self):
        """Запускает отправку сообщения в новом event loop"""
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            loop.run_until_complete(self.send_message_to_channel())
        except Exception as e:
            logger.error(f"❌ Ошибка в новом event loop: {e}")
        finally:
            # Простое и безопасное закрытие loop
            try:
                loop.close()
            except Exception:
                pass

    def send_voice_message_sync(self):
        """Синхронная обертка для отправки голосового сообщения"""
        try:
            # Всегда создаем новый event loop для изоляции
            import concurrent.futures
            with concurrent.futures.ThreadPoolExecutor() as executor:
                future = executor.submit(self._run_voice_in_new_loop)
                future.result(timeout=180)  # 3 минуты таймаут для голосовых
        except Exception as e:
            logger.error(f"❌ Ошибка в send_voice_message_sync: {e}")
            # Последняя попытка с простым asyncio.run
            try:
                asyncio.run(self.send_voice_message_to_channel())
            except Exception as e2:
                logger.error(f"❌ Критическая ошибка в send_voice_message_sync: {e2}")
    
    def _run_voice_in_new_loop(self):
        """Запускает отправку голосового сообщения в новом event loop"""
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            loop.run_until_complete(self.send_voice_message_to_channel())
        except Exception as e:
            logger.error(f"❌ Ошибка в новом event loop для голоса: {e}")
        finally:
            # Простое и безопасное закрытие loop
            try:
                loop.close()
            except Exception:
                pass

    def send_test_voice_messages(self, count=5):
        """Отправляет тестовые голосовые сообщения подряд"""
        logger.info(f"🎤 Начинаем отправку {count} тестовых голосовых сообщений")
        
        for i in range(count):
            try:
                logger.info(f"📤 Отправляем голосовое сообщение {i+1}/{count}")
                self.send_voice_message_sync()
                
                # Пауза между сообщениями
                if i < count - 1:
                    time.sleep(2)
                    
            except Exception as e:
                logger.error(f"❌ Ошибка при отправке тестового сообщения {i+1}: {e}")
        
        logger.info(f"✅ Отправка {count} тестовых голосовых сообщений завершена")

    def send_completion_message_sync(self, reply_to_message_id=None):
        """Синхронная обертка для отправки ответного сообщения (всегда отвечает на последнее сообщение)"""
        try:
            # Всегда отвечаем на последнее сообщение бота, если не указан конкретный ID
            if reply_to_message_id is None:
                reply_to_message_id = self.last_message_id
            
            # Всегда создаем новый event loop для изоляции
            import concurrent.futures
            with concurrent.futures.ThreadPoolExecutor() as executor:
                future = executor.submit(self._run_completion_in_new_loop, reply_to_message_id)
                future.result(timeout=120)  # 2 минуты таймаут
        except Exception as e:
            logger.error(f"❌ Ошибка в send_completion_message_sync: {e}")
            # Последняя попытка с простым asyncio.run
            try:
                asyncio.run(self.send_completion_message_to_channel(reply_to_message_id))
            except Exception as e2:
                logger.error(f"❌ Критическая ошибка в send_completion_message_sync: {e2}")
    
    def _run_completion_in_new_loop(self, reply_to_message_id=None):
        """Запускает отправку ответного сообщения в новом event loop"""
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            loop.run_until_complete(self.send_completion_message_to_channel(reply_to_message_id))
        except Exception as e:
            logger.error(f"❌ Ошибка в новом event loop для completion: {e}")
        finally:
            # Простое и безопасное закрытие loop
            try:
                loop.close()
            except Exception:
                pass

    def schedule_messages(self):
        """Планирует отправку сообщений 8 раз в день: 4 голосовых, 2 текстовых, 2 ответных"""
        # 7:00 утра - ГОЛОСОВОЕ СООБЩЕНИЕ
        schedule.every().day.at("07:00").do(self.send_voice_message_sync)
        # 9:00 утра - ТЕКСТОВОЕ СООБЩЕНИЕ
        schedule.every().day.at("09:00").do(self.send_message_sync)
        # 11:00 утра - ГОЛОСОВОЕ СООБЩЕНИЕ
        schedule.every().day.at("11:00").do(self.send_voice_message_sync)
        # 13:00 дня - ТЕКСТОВОЕ СООБЩЕНИЕ
        schedule.every().day.at("13:00").do(self.send_message_sync)
        # 15:00 дня - ГОЛОСОВОЕ СООБЩЕНИЕ
        schedule.every().day.at("15:00").do(self.send_voice_message_sync)
        # 17:00 дня - ГОЛОСОВОЕ СООБЩЕНИЕ
        schedule.every().day.at("17:00").do(self.send_voice_message_sync)
        # 19:00 вечера - ТЕКСТОВОЕ СООБЩЕНИЕ
        schedule.every().day.at("19:00").do(self.send_message_sync)
        # 21:00 вечера - ГОЛОСОВОЕ СООБЩЕНИЕ
        schedule.every().day.at("21:00").do(self.send_voice_message_sync)
        # 23:00 вечера - ответное сообщение (работа выполнена)
        schedule.every().day.at("23:00").do(self.send_completion_message_sync)
        # 1:00 ночи - ответное сообщение (работа выполнена)
        schedule.every().day.at("01:00").do(self.send_completion_message_sync)
        
        logger.info("Расписание сообщений настроено: 07:00 (🎤), 09:00 (📝), 11:00 (🎤), 13:00 (📝), 15:00 (🎤), 17:00 (🎤), 19:00 (📝), 21:00 (🎤), 23:00 (✅), 01:00 (✅)")

    def run_scheduler(self):
        """Запускает планировщик в отдельном потоке с улучшенной обработкой ошибок"""
        while True:
            try:
                schedule.run_pending()
                time.sleep(60)  # Проверяем каждую минуту
            except Exception as e:
                logger.error(f"❌ Ошибка в планировщике: {e}")
                # При критических ошибках перезапускаем планировщик
                try:
                    schedule.clear()
                    self.schedule_messages()
                    logger.info("🔄 Планировщик перезапущен")
                except Exception as restart_e:
                    logger.error(f"❌ Ошибка перезапуска планировщика: {restart_e}")
                time.sleep(60)  # Продолжаем работу даже при ошибке

    async def start_bot(self):
        """Запускает бота"""
        try:
            # Проверяем подключение
            me = await self.bot.get_me()
            logger.info(f"Бот запущен: @{me.username}")
            
            # Настраиваем расписание
            self.schedule_messages()
            
            # Запускаем планировщик в отдельном потоке
            scheduler_thread = Thread(target=self.run_scheduler, daemon=True)
            scheduler_thread.start()
            
            logger.info("Бот готов к работе! Сообщения будут отправляться в 07:00 (🎤), 09:00 (📝), 11:00 (🎤), 13:00 (📝), 15:00 (📝), 17:00 (🎤), 19:00 (📝), 21:00 (📝), 23:00 (✅), 01:00 (✅)")
            
            # Отправляем несколько тестовых сообщений для проверки
            logger.info("🚀 Отправляем тестовые сообщения...")
            
            try:
                await self.send_message_to_channel()
                logger.info("✅ Тестовое текстовое сообщение 1 отправлено")
            except Exception as e:
                logger.error(f"❌ Ошибка тестового сообщения 1: {e}")
            
            await asyncio.sleep(5)
            
            try:
                await self.send_message_with_photos_to_channel()
                logger.info("📸 Тестовое сообщение с фотографиями отправлено")
            except Exception as e:
                logger.error(f"❌ Ошибка тестового сообщения с фото: {e}")
            
            await asyncio.sleep(5)
            
            try:
                await self.send_voice_message_to_channel()
                logger.info("🎤 Тестовое голосовое сообщение отправлено")
            except Exception as e:
                logger.error(f"❌ Ошибка тестового голосового сообщения: {e}")
            
            await asyncio.sleep(5)
            
            try:
                await self.send_message_to_channel()
                logger.info("✅ Тестовое текстовое сообщение 2 отправлено")
            except Exception as e:
                logger.error(f"❌ Ошибка тестового сообщения 2: {e}")
            
            await asyncio.sleep(5)
            
            try:
                # Отправляем ответное сообщение с reply на предыдущее
                await self.send_completion_message_to_channel()
                logger.info("✅ Тестовое ответное сообщение отправлено")
            except Exception as e:
                logger.error(f"❌ Ошибка тестового ответного сообщения: {e}")
            
            await asyncio.sleep(5)
            
            try:
                # Отправляем еще одно ответное сообщение с reply
                await self.send_completion_message_to_channel()
                logger.info("✅ Тестовое ответное сообщение 2 отправлено")
            except Exception as e:
                logger.error(f"❌ Ошибка тестового ответного сообщения 2: {e}")
            
            # Держим бота активным
            while True:
                try:
                    await asyncio.sleep(3600)  # Спим час
                except Exception as e:
                    logger.error(f"❌ Ошибка в основном цикле бота: {e}")
                    await asyncio.sleep(60)  # Короткая пауза при ошибке
                
        except Exception as e:
            logger.error(f"Ошибка при запуске бота: {e}")
            raise

def signal_handler(signum, frame):
    """Обработчик сигналов для graceful shutdown"""
    logger.info(f"Получен сигнал {signum}, завершаем работу...")
    sys.exit(0)

def main():
    """Главная функция с улучшенной обработкой ошибок для Railway"""
    # Регистрируем обработчики сигналов
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    bot = WorkBot()
    
    # Тестовая отправка 5 голосовых сообщений
    try:
        logger.info("🎤 Запускаем тестовую отправку 5 голосовых сообщений")
        bot.send_test_voice_messages(5)
        logger.info("✅ Тестовая отправка завершена")
    except Exception as e:
        logger.error(f"❌ Ошибка при тестовой отправке: {e}")
    
    try:
        # Настраиваем event loop для Railway
        if os.getenv("RAILWAY_ENVIRONMENT"):
            # В Railway используем более консервативные настройки
            asyncio.set_event_loop_policy(asyncio.DefaultEventLoopPolicy())
            # Устанавливаем более короткие таймауты для Railway
            logger.info("🚀 Запуск в Railway environment")
        
        asyncio.run(bot.start_bot())
    except KeyboardInterrupt:
        logger.info("Бот остановлен пользователем")
    except Exception as e:
        logger.error(f"Критическая ошибка: {e}")
        # В Railway перезапускаемся при критических ошибках
        if os.getenv("RAILWAY_ENVIRONMENT"):
            logger.info("Перезапуск через 30 секунд...")
            time.sleep(30)
            main()  # Рекурсивный перезапуск
        else:
            raise

if __name__ == "__main__":
    main()
